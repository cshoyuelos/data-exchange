<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>dataexchange.xtomo.formats.xradia_xrm &mdash; Data Exchange 0.2 documentation</title>
    
    <link rel="stylesheet" href="../../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '0.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="author" title="About these documents" href="../../../../about.html" />
    <link rel="top" title="Data Exchange 0.2 documentation" href="../../../../index.html" />
    <link rel="up" title="Module code" href="../../../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../../index.html">Data Exchange 0.2 documentation</a> &raquo;</li>
          <li><a href="../../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for dataexchange.xtomo.formats.xradia_xrm</h1><div class="highlight"><pre>
<span class="c"># </span>
<span class="c">#   This file is part of Mantis, a Multivariate ANalysis Tool for Spectromicroscopy.</span>
<span class="c"># </span>
<span class="c">#   Copyright (C) 2011 Mirna Lerotic, 2nd Look</span>
<span class="c">#   http://2ndlook.co/products.html</span>
<span class="c">#   License: GNU GPL v3</span>
<span class="c">#</span>
<span class="c">#   Mantis is free software: you can redistribute it and/or modify</span>
<span class="c">#   it under the terms of the GNU General Public License as published by</span>
<span class="c">#   the Free Software Foundation, either version 3 of the License, or</span>
<span class="c">#   any later version.</span>
<span class="c">#</span>
<span class="c">#   Mantis is distributed in the hope that it will be useful,</span>
<span class="c">#   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c">#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c">#   GNU General Public License for more details &lt;http://www.gnu.org/licenses/&gt;.</span>



<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span> <span class="kn">as</span> <span class="nn">scy</span>
<span class="kn">import</span> <span class="nn">struct</span>
            
<span class="kn">import</span> <span class="nn">data_struct</span>



<span class="c">#----------------------------------------------------------------------</span>
<div class="viewcode-block" id="xrm"><a class="viewcode-back" href="../../../../resources/dataexchange.xtomo.formats.xradia_xrm.html#dataexchange.xtomo.formats.xradia_xrm.xrm">[docs]</a><span class="k">class</span> <span class="nc">xrm</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
 
 
<span class="c">#----------------------------------------------------------------------</span>
<div class="viewcode-block" id="xrm.read_xrm_fileinfo"><a class="viewcode-back" href="../../../../resources/dataexchange.xtomo.formats.xradia_xrm.html#dataexchange.xtomo.formats.xradia_xrm.xrm.read_xrm_fileinfo">[docs]</a>    <span class="k">def</span> <span class="nf">read_xrm_fileinfo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span> 
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isOleFile</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
            <span class="k">print</span> <span class="s">&quot;File not valid OLE type.&quot;</span>
            <span class="k">return</span>
        <span class="c"># Open OLE file:</span>
        <span class="n">ole</span> <span class="o">=</span> <span class="n">OleFileIO</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        
        <span class="n">verbose</span> <span class="o">=</span> <span class="bp">False</span>
        
        <span class="k">if</span> <span class="n">ole</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">&#39;ImageInfo/ImagesTaken&#39;</span><span class="p">):</span>                  
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="s">&#39;ImageInfo/ImagesTaken&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">nev</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">&#39;&lt;I&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;ImageInfo/ImagesTaken = </span><span class="si">%i</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">nev</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  
            <span class="n">nimgs</span> <span class="o">=</span> <span class="n">nev</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">nimgs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">nimgs</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">nimgs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;This file has more than one image and cannot be used to make a stack.&#39;</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>

                
        <span class="k">if</span> <span class="n">ole</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">&#39;ImageInfo/ImageWidth&#39;</span><span class="p">):</span>                 
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="s">&#39;ImageInfo/ImageWidth&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">nev</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">&#39;&lt;I&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;ImageInfo/ImageWidth = </span><span class="si">%i</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">nev</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  
            <span class="n">n_cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">nev</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                
        <span class="k">if</span> <span class="n">ole</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">&#39;ImageInfo/ImageHeight&#39;</span><span class="p">):</span>                  
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="s">&#39;ImageInfo/ImageHeight&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">nev</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">&#39;&lt;I&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;ImageInfo/ImageHeight = </span><span class="si">%i</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">nev</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  
            <span class="n">n_rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">nev</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            
        <span class="k">if</span> <span class="n">ole</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">&#39;ImageInfo/Energy&#39;</span><span class="p">):</span>                  
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="s">&#39;ImageInfo/Energy&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">struct_fmt</span> <span class="o">=</span> <span class="s">&quot;&lt;{}f&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nimgs</span><span class="p">)</span>
            <span class="n">eV</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">struct_fmt</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;ImageInfo/Energy: </span><span class="se">\n</span><span class="s"> &quot;</span><span class="p">,</span>  <span class="n">eV</span> 

            
        <span class="c">#Energy saved in the file is too coarse - read it from the filename</span>
        <span class="n">str_list</span> <span class="o">=</span> <span class="n">filename</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span> <span class="c">#look for &#39;eV&#39; filed in the filename</span>
            <span class="n">ev_ind</span> <span class="o">=</span> <span class="n">str_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;eV&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span><span class="k">print</span> <span class="s">&#39;Energy value from filename = &#39;</span><span class="p">,</span> <span class="n">str_list</span><span class="p">[</span><span class="n">ev_ind</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">eV</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">str_list</span><span class="p">[</span><span class="n">ev_ind</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span><span class="k">print</span> <span class="s">&#39;Using energy stored in the file.&#39;</span>
            
        <span class="n">ole</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            
        <span class="k">return</span> <span class="n">n_cols</span><span class="p">,</span> <span class="n">n_rows</span><span class="p">,</span> <span class="n">eV</span>

        
<span class="c">#----------------------------------------------------------------------    </span></div>
<div class="viewcode-block" id="xrm.read_xrm_list"><a class="viewcode-back" href="../../../../resources/dataexchange.xtomo.formats.xradia_xrm.html#dataexchange.xtomo.formats.xradia_xrm.xrm.read_xrm_list">[docs]</a>    <span class="k">def</span> <span class="nf">read_xrm_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filelist</span><span class="p">,</span> <span class="n">filepath</span><span class="p">,</span> <span class="n">ds</span><span class="p">):</span> 
        
        <span class="c">#Fill the common stack data </span>
        <span class="n">file1</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">filelist</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>   


        <span class="k">if</span> <span class="ow">not</span> <span class="n">isOleFile</span><span class="p">(</span><span class="n">file1</span><span class="p">):</span>
            <span class="k">print</span> <span class="s">&quot;File not valid OLE type.&quot;</span>
            <span class="k">return</span>
        <span class="c"># Open OLE file:</span>
        <span class="n">ole</span> <span class="o">=</span> <span class="n">OleFileIO</span><span class="p">(</span><span class="n">file1</span><span class="p">)</span>
        
        <span class="n">verbose</span> <span class="o">=</span> <span class="bp">False</span>
        
        
        <span class="k">if</span> <span class="n">ole</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">&#39;Version&#39;</span><span class="p">):</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="s">&#39;Version&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">version</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">&#39;&lt;f&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;version = &quot;</span><span class="p">,</span> <span class="n">version</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  
                           
        <span class="k">if</span> <span class="n">ole</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">&#39;SampleInfo/Analyst&#39;</span><span class="p">):</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="s">&#39;SampleInfo/Analyst&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">analyst</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">&#39;&lt;50s&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="n">analyst</span> <span class="o">=</span> <span class="n">analyst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;SampleInfo/Analyst = </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">analyst</span>
            
            
        <span class="k">if</span> <span class="n">ole</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">&#39;SampleInfo/Facility&#39;</span><span class="p">):</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="s">&#39;SampleInfo/Facility&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">facility</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">&#39;&lt;50s&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="n">facility</span> <span class="o">=</span> <span class="n">facility</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;SampleInfo/Facility = </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">facility</span>
                
        <span class="k">if</span> <span class="n">ole</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">&#39;SampleInfo/SampleID&#39;</span><span class="p">):</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="s">&#39;SampleInfo/SampleID&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">&#39;&lt;50s&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="n">sample</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;SampleInfo/SampleID = </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">sample</span>
        
            
        <span class="k">if</span> <span class="n">ole</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">&#39;ImageInfo/ImageWidth&#39;</span><span class="p">):</span>                 
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="s">&#39;ImageInfo/ImageWidth&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">nev</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">&#39;&lt;I&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;ImageInfo/ImageWidth = </span><span class="si">%i</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">nev</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  
            <span class="n">ncols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">nev</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                
        <span class="k">if</span> <span class="n">ole</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">&#39;ImageInfo/ImageHeight&#39;</span><span class="p">):</span>                  
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="s">&#39;ImageInfo/ImageHeight&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">nev</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">&#39;&lt;I&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;ImageInfo/ImageHeight = </span><span class="si">%i</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">nev</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  
            <span class="n">nrows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">nev</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>        

        <span class="n">npix</span> <span class="o">=</span> <span class="n">ncols</span><span class="o">*</span><span class="n">nrows</span>
        <span class="n">nev</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">filelist</span><span class="p">)</span>
        <span class="n">absdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ncols</span><span class="p">,</span> <span class="n">nrows</span><span class="p">,</span> <span class="n">nev</span><span class="p">))</span>
        <span class="n">ev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nev</span><span class="p">))</span>
        
        
        <span class="k">if</span> <span class="n">ole</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">&#39;ImageInfo/PixelSize&#39;</span><span class="p">):</span>                  
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="s">&#39;ImageInfo/PixelSize&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">struct_fmt</span> <span class="o">=</span> <span class="s">&#39;&lt;1f&#39;</span>
            <span class="n">pixelsize</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">struct_fmt</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="n">pixelsize</span> <span class="o">=</span> <span class="n">pixelsize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;ImageInfo/PixelSize: </span><span class="si">%f</span><span class="s"> &quot;</span> <span class="o">%</span>  <span class="n">pixelsize</span>  
            
        <span class="k">if</span> <span class="n">ole</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">&#39;ImageInfo/ImagesTaken&#39;</span><span class="p">):</span>                  
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="s">&#39;ImageInfo/ImagesTaken&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">&#39;&lt;I&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;ImageInfo/ImagesTaken = </span><span class="si">%i</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  
            <span class="n">nimgs</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">nimgs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">nimgs</span><span class="p">)</span>

                
        <span class="k">if</span> <span class="n">ole</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">&#39;ImageInfo/ExpTimes&#39;</span><span class="p">):</span>                  
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="s">&#39;ImageInfo/ExpTimes&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">struct_fmt</span> <span class="o">=</span> <span class="s">&quot;&lt;{}f&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nimgs</span><span class="p">)</span>
            <span class="n">exptimes</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">struct_fmt</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;ImageInfo/ExpTimes: </span><span class="se">\n</span><span class="s"> &quot;</span><span class="p">,</span>  <span class="n">exptimes</span>
            
                
        <span class="c"># 10 float; 5 uint16 (unsigned 16-bit (2-byte) integers)</span>
        <span class="k">if</span> <span class="n">ole</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">&#39;ImageInfo/DataType&#39;</span><span class="p">):</span>                  
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="s">&#39;ImageInfo/DataType&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">struct_fmt</span> <span class="o">=</span> <span class="s">&#39;&lt;1I&#39;</span>
            <span class="n">datatype</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">struct_fmt</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="n">datatype</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">datatype</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;ImageInfo/DataType: </span><span class="si">%f</span><span class="s"> &quot;</span> <span class="o">%</span>  <span class="n">datatype</span>  
            
                   
        <span class="c">#Read the image data        </span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">filelist</span><span class="p">)):</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="n">filelist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">fn</span><span class="p">)</span>   
            <span class="n">ole</span> <span class="o">=</span> <span class="n">OleFileIO</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>  
            
            <span class="c">#folder contains 100 images 1-100, 101-200...           </span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nimgs</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">img_string</span> <span class="o">=</span> <span class="s">&quot;ImageData</span><span class="si">%i</span><span class="s">/Image</span><span class="si">%i</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">i</span><span class="o">/</span><span class="mf">100.0</span><span class="p">),</span> <span class="n">i</span><span class="p">)</span>
                <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="n">img_string</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
                <span class="c"># 10 float; 5 uint16 (unsigned 16-bit (2-byte) integers)</span>
                <span class="k">if</span> <span class="n">datatype</span> <span class="o">==</span> <span class="mi">10</span><span class="p">:</span>
                    <span class="n">struct_fmt</span> <span class="o">=</span> <span class="s">&quot;&lt;{}f&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">npix</span><span class="p">)</span>
                    <span class="n">imgdata</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">npix</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">datatype</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>                   
                    <span class="n">struct_fmt</span> <span class="o">=</span> <span class="s">&quot;&lt;{}h&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">npix</span><span class="p">)</span>
                    <span class="n">imgdata</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">struct_fmt</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>                            
                    <span class="k">print</span> <span class="s">&quot;Wrong data type&quot;</span>
                    <span class="k">return</span>
                    
            <span class="n">absdata</span><span class="p">[:,:,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">imgdata</span><span class="p">,</span> <span class="p">(</span><span class="n">ncols</span><span class="p">,</span> <span class="n">nrows</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;F&#39;</span><span class="p">)</span>
            
                
            <span class="n">ole</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            
           
            <span class="c">#Energy saved in the file is too coarse - read it from the filename</span>
            <span class="n">str_list</span> <span class="o">=</span> <span class="n">filename</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span> <span class="c">#look for &#39;eV&#39; filed in the filename</span>
                <span class="n">ev_ind</span> <span class="o">=</span> <span class="n">str_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;eV&#39;</span><span class="p">)</span>
                <span class="n">this_ev</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">str_list</span><span class="p">[</span><span class="n">ev_ind</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span><span class="k">print</span> <span class="s">&#39;Using energy stored in the file.&#39;</span>   
                    
            <span class="n">ev</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_ev</span>
            
            
            
        <span class="k">if</span> <span class="n">ev</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="n">ev</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">ev</span> <span class="o">=</span> <span class="n">ev</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">absdata</span> <span class="o">=</span> <span class="n">absdata</span><span class="p">[:,:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            
       
        
        <span class="c">#Fill the data structure with data: </span>
        <span class="n">ds</span><span class="o">.</span><span class="n">implements</span> <span class="o">=</span> <span class="s">&#39;information:exchange:spectromicroscopy&#39;</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">version</span> <span class="o">=</span> <span class="s">&#39;1.0&#39;</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">information</span><span class="o">.</span><span class="n">comment</span> <span class="o">=</span> <span class="s">&#39;Converted from .xrm file list&#39;</span><span class="p">,</span>
        
        <span class="kn">import</span> <span class="nn">datetime</span> 
        <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">information</span><span class="o">.</span><span class="n">file_creation_datetime</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s">&quot;%Y-%m-</span><span class="si">%d</span><span class="s">T%H:%M&quot;</span><span class="p">)</span>

        <span class="n">ds</span><span class="o">.</span><span class="n">information</span><span class="o">.</span><span class="n">experimenter</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">analyst</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">information</span><span class="o">.</span><span class="n">sample</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">sample</span>
        
        <span class="n">ds</span><span class="o">.</span><span class="n">exchange</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">absdata</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">exchange</span><span class="o">.</span><span class="n">data_signal</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">exchange</span><span class="o">.</span><span class="n">data_axes</span><span class="o">=</span><span class="s">&#39;x:y&#39;</span>
        
        <span class="n">ds</span><span class="o">.</span><span class="n">exchange</span><span class="o">.</span><span class="n">energy</span><span class="o">=</span><span class="n">ev</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">exchange</span><span class="o">.</span><span class="n">energy_units</span> <span class="o">=</span> <span class="s">&#39;ev&#39;</span>
        
        
        <span class="c">#Since we do not have a scanning microscope we fill the x_dist and y_dist from pixel_size</span>
        <span class="n">x_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="n">ncols</span><span class="p">))</span><span class="o">*</span><span class="n">pixelsize</span>
        <span class="n">y_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="n">nrows</span><span class="p">))</span><span class="o">*</span><span class="n">pixelsize</span>
    
        <span class="n">ds</span><span class="o">.</span><span class="n">exchange</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x_dist</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">exchange</span><span class="o">.</span><span class="n">x_units</span> <span class="o">=</span> <span class="s">&#39;um&#39;</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">exchange</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y_dist</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">exchange</span><span class="o">.</span><span class="n">y_units</span> <span class="o">=</span> <span class="s">&#39;um&#39;</span>     
        
        
        
        <span class="bp">self</span><span class="o">.</span><span class="n">data_dwell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">nev</span><span class="p">))</span><span class="o">*</span><span class="n">exptimes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">spectromicroscopy</span><span class="o">.</span><span class="n">data_dwell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_dwell</span>
        

            
        
        
        <span class="k">return</span>
    
<span class="c">#----------------------------------------------------------------------</span></div>
<div class="viewcode-block" id="xrm.read_xrm"><a class="viewcode-back" href="../../../../resources/dataexchange.xtomo.formats.xradia_xrm.html#dataexchange.xtomo.formats.xradia_xrm.xrm.read_xrm">[docs]</a>    <span class="k">def</span> <span class="nf">read_xrm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">ds</span><span class="p">):</span>
            
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isOleFile</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
            <span class="k">print</span> <span class="s">&quot;File not valid OLE type.&quot;</span>
            <span class="k">return</span>
        <span class="c"># Open OLE file:</span>
        <span class="n">ole</span> <span class="o">=</span> <span class="n">OleFileIO</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="c"># Get list of streams:</span>
        <span class="c">#list = ole.listdir()</span>
        <span class="c">#print list</span>
        
        <span class="n">verbose</span> <span class="o">=</span> <span class="bp">False</span>
        

        <span class="c"># Test if known streams/storages exist:</span>
        <span class="k">if</span> <span class="n">ole</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">&#39;Version&#39;</span><span class="p">):</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="s">&#39;Version&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">version</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">&#39;&lt;f&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;version = &quot;</span><span class="p">,</span> <span class="n">version</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  
                           
        <span class="k">if</span> <span class="n">ole</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">&#39;SampleInfo/Analyst&#39;</span><span class="p">):</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="s">&#39;SampleInfo/Analyst&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">analyst</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">&#39;&lt;50s&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="n">analyst</span> <span class="o">=</span> <span class="n">analyst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;SampleInfo/Analyst = </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">analyst</span>
                
        <span class="k">if</span> <span class="n">ole</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">&#39;SampleInfo/Facility&#39;</span><span class="p">):</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="s">&#39;SampleInfo/Facility&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">facility</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">&#39;&lt;50s&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="n">facility</span> <span class="o">=</span> <span class="n">facility</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;SampleInfo/Facility = </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">facility</span>
                
        <span class="k">if</span> <span class="n">ole</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">&#39;SampleInfo/SampleID&#39;</span><span class="p">):</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="s">&#39;SampleInfo/SampleID&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">&#39;&lt;50s&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="n">sample</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;SampleInfo/SampleID = </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">sample</span>
                
                
                
        <span class="n">datasize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ole</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">&#39;ImageInfo/ImagesTaken&#39;</span><span class="p">):</span>                  
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="s">&#39;ImageInfo/ImagesTaken&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">nev</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">&#39;&lt;I&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;ImageInfo/ImagesTaken = </span><span class="si">%i</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">nev</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  
            <span class="n">nimgs</span> <span class="o">=</span> <span class="n">nev</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">datasize</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">nimgs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_ev</span> <span class="o">=</span> <span class="n">datasize</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                
        <span class="k">if</span> <span class="n">ole</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">&#39;ImageInfo/ImageWidth&#39;</span><span class="p">):</span>                 
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="s">&#39;ImageInfo/ImageWidth&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">nev</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">&#39;&lt;I&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;ImageInfo/ImageWidth = </span><span class="si">%i</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">nev</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  
            <span class="n">datasize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">nev</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_cols</span> <span class="o">=</span> <span class="n">datasize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                
        <span class="k">if</span> <span class="n">ole</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">&#39;ImageInfo/ImageHeight&#39;</span><span class="p">):</span>                  
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="s">&#39;ImageInfo/ImageHeight&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">nev</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">&#39;&lt;I&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;ImageInfo/ImageHeight = </span><span class="si">%i</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">nev</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  
            <span class="n">datasize</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">nev</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_rows</span> <span class="o">=</span> <span class="n">datasize</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                
        <span class="k">if</span> <span class="n">ole</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">&#39;ImageInfo/Angles&#39;</span><span class="p">):</span>                  
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="s">&#39;ImageInfo/Angles&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">struct_fmt</span> <span class="o">=</span> <span class="s">&quot;&lt;{0}f&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nimgs</span><span class="p">)</span>
            <span class="n">angles</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">struct_fmt</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;ImageInfo/Angles: </span><span class="se">\n</span><span class="s"> &quot;</span><span class="p">,</span>  <span class="n">angles</span>  
                
        <span class="k">if</span> <span class="n">ole</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">&#39;ImageInfo/Energy&#39;</span><span class="p">):</span>                  
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="s">&#39;ImageInfo/Energy&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">struct_fmt</span> <span class="o">=</span> <span class="s">&quot;&lt;{0}f&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nimgs</span><span class="p">)</span>
            <span class="n">eng</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">struct_fmt</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;ImageInfo/Energy: </span><span class="se">\n</span><span class="s"> &quot;</span><span class="p">,</span>  <span class="n">eng</span>  
            <span class="bp">self</span><span class="o">.</span><span class="n">ev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">eng</span><span class="p">)</span>
            
        <span class="c">#Energy saved in the file is too coarse - read it from the filename</span>
        <span class="n">str_list</span> <span class="o">=</span> <span class="n">filename</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span> <span class="c">#look for &#39;eV&#39; filed in the filename</span>
            <span class="n">ev_ind</span> <span class="o">=</span> <span class="n">str_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;eV&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span><span class="k">print</span> <span class="s">&#39;Energy value from filename = &#39;</span><span class="p">,</span> <span class="n">str_list</span><span class="p">[</span><span class="n">ev_ind</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">eng</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">str_list</span><span class="p">[</span><span class="n">ev_ind</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ev</span> <span class="o">=</span> <span class="p">[</span><span class="n">eng</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span><span class="k">print</span> <span class="s">&#39;Using energy stored in the file.&#39;</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">ev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ev</span><span class="p">)</span>
                
        <span class="k">if</span> <span class="n">ole</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">&#39;ImageInfo/PixelSize&#39;</span><span class="p">):</span>                  
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="s">&#39;ImageInfo/PixelSize&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">struct_fmt</span> <span class="o">=</span> <span class="s">&#39;&lt;1f&#39;</span>
            <span class="n">pixelsize</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">struct_fmt</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="n">pixelsize</span> <span class="o">=</span> <span class="n">pixelsize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;ImageInfo/PixelSize: </span><span class="si">%f</span><span class="s"> &quot;</span> <span class="o">%</span>  <span class="n">pixelsize</span>  
                
        <span class="k">if</span> <span class="n">ole</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">&#39;ImageInfo/ExpTimes&#39;</span><span class="p">):</span>                  
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="s">&#39;ImageInfo/ExpTimes&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">struct_fmt</span> <span class="o">=</span> <span class="s">&quot;&lt;{0}f&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nimgs</span><span class="p">)</span>
            <span class="n">exptimes</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">struct_fmt</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;ImageInfo/ExpTimes: </span><span class="se">\n</span><span class="s"> &quot;</span><span class="p">,</span>  <span class="n">exptimes</span>
            
                
        <span class="c"># 10 float; 5 uint16 (unsigned 16-bit (2-byte) integers)</span>
        <span class="k">if</span> <span class="n">ole</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">&#39;ImageInfo/DataType&#39;</span><span class="p">):</span>                  
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="s">&#39;ImageInfo/DataType&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">struct_fmt</span> <span class="o">=</span> <span class="s">&#39;&lt;1I&#39;</span>
            <span class="n">datatype</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">struct_fmt</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="n">datatype</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">datatype</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;ImageInfo/DataType: </span><span class="si">%f</span><span class="s"> &quot;</span> <span class="o">%</span>  <span class="n">datatype</span>  
         
            
        <span class="bp">self</span><span class="o">.</span><span class="n">absdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_ev</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="c">#Read the images - They are stored in ImageData1, ImageData2... Each</span>
        <span class="c">#folder contains 100 images 1-100, 101-200...           </span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nimgs</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">img_string</span> <span class="o">=</span> <span class="s">&quot;ImageData</span><span class="si">%i</span><span class="s">/Image</span><span class="si">%i</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">i</span><span class="o">/</span><span class="mf">100.0</span><span class="p">),</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="n">img_string</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="c"># 10 float; 5 uint16 (unsigned 16-bit (2-byte) integers)</span>
            <span class="k">if</span> <span class="n">datatype</span> <span class="o">==</span> <span class="mi">10</span><span class="p">:</span>
                <span class="n">struct_fmt</span> <span class="o">=</span> <span class="s">&quot;&lt;{0}f&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_cols</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_rows</span><span class="p">)</span>
                <span class="n">imgdata</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">struct_fmt</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">datatype</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>                   
                <span class="n">struct_fmt</span> <span class="o">=</span> <span class="s">&quot;&lt;{0}h&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_cols</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_rows</span><span class="p">)</span>
                <span class="n">imgdata</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">struct_fmt</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>                            
                <span class="k">print</span> <span class="s">&quot;Wrong data type&quot;</span>
                <span class="k">return</span>
                    
            <span class="bp">self</span><span class="o">.</span><span class="n">absdata</span><span class="p">[:,:,</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">imgdata</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_rows</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;F&#39;</span><span class="p">)</span>
                
                
        <span class="n">ole</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                
        <span class="c">#Fill the data structure with data: </span>
        <span class="n">ds</span><span class="o">.</span><span class="n">implements</span> <span class="o">=</span> <span class="s">&#39;information:exchange:spectromicroscopy&#39;</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">version</span> <span class="o">=</span> <span class="s">&#39;1.0&#39;</span>
        
        
        <span class="n">ds</span><span class="o">.</span><span class="n">information</span><span class="o">.</span><span class="n">comment</span> <span class="o">=</span> <span class="s">&#39;Converted from .txrm (Xradia file format)&#39;</span><span class="p">,</span>
        

        <span class="n">ds</span><span class="o">.</span><span class="n">information</span><span class="o">.</span><span class="n">experimenter</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">analyst</span>
        
        <span class="n">ds</span><span class="o">.</span><span class="n">information</span><span class="o">.</span><span class="n">sample</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">sample</span>
        
        <span class="n">ds</span><span class="o">.</span><span class="n">exchange</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">absdata</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">exchange</span><span class="o">.</span><span class="n">data_signal</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">exchange</span><span class="o">.</span><span class="n">data_axes</span><span class="o">=</span><span class="s">&#39;x:y&#39;</span>
        
        <span class="n">ds</span><span class="o">.</span><span class="n">exchange</span><span class="o">.</span><span class="n">energy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ev</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">exchange</span><span class="o">.</span><span class="n">energy_units</span> <span class="o">=</span> <span class="s">&#39;ev&#39;</span>
        
        
        <span class="c">#Since we do not have a scanning microscope we fill the x_dist and y_dist from pixel_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_cols</span><span class="p">))</span><span class="o">*</span><span class="n">pixelsize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_rows</span><span class="p">))</span><span class="o">*</span><span class="n">pixelsize</span>
    
        <span class="n">ds</span><span class="o">.</span><span class="n">exchange</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dist</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">exchange</span><span class="o">.</span><span class="n">x_units</span> <span class="o">=</span> <span class="s">&#39;um&#39;</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">exchange</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_dist</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">exchange</span><span class="o">.</span><span class="n">y_units</span> <span class="o">=</span> <span class="s">&#39;um&#39;</span>     
    
        <span class="n">ds</span><span class="o">.</span><span class="n">exchange</span><span class="o">.</span><span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span>
        
        <span class="n">ds</span><span class="o">.</span><span class="n">spectromicroscopy</span><span class="o">.</span><span class="n">data_dwell</span> <span class="o">=</span> <span class="n">exptimes</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">data_dwell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_ev</span><span class="p">))</span><span class="o">*</span><span class="n">exptimes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
          
          
        <span class="k">return</span>
    
             
    
<span class="c">#----------------------------------------------------------------------</span></div>
<div class="viewcode-block" id="xrm.read_txrm"><a class="viewcode-back" href="../../../../resources/dataexchange.xtomo.formats.xradia_xrm.html#dataexchange.xtomo.formats.xradia_xrm.xrm.read_txrm">[docs]</a>    <span class="k">def</span> <span class="nf">read_txrm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">ds</span><span class="p">):</span>
            
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isOleFile</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
            <span class="k">print</span> <span class="s">&quot;File not valid OLE type.&quot;</span>
            <span class="k">return</span>
        <span class="c"># Open OLE file:</span>
        <span class="n">ole</span> <span class="o">=</span> <span class="n">OleFileIO</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="c"># Get list of streams:</span>
        <span class="c">#list = ole.listdir()</span>
        <span class="c">#print list</span>
        
        <span class="n">verbose</span> <span class="o">=</span> <span class="bp">False</span>


        <span class="c"># Test if known streams/storages exist:</span>
        <span class="k">if</span> <span class="n">ole</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">&#39;Version&#39;</span><span class="p">):</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="s">&#39;Version&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">version</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">&#39;&lt;f&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;version = &quot;</span><span class="p">,</span> <span class="n">version</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  
                           
        <span class="k">if</span> <span class="n">ole</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">&#39;SampleInfo/Analyst&#39;</span><span class="p">):</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="s">&#39;SampleInfo/Analyst&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">analyst</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">&#39;&lt;50s&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="n">analyst</span> <span class="o">=</span> <span class="n">analyst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;SampleInfo/Analyst = </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">analyst</span>
                
        <span class="k">if</span> <span class="n">ole</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">&#39;SampleInfo/Facility&#39;</span><span class="p">):</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="s">&#39;SampleInfo/Facility&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">facility</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">&#39;&lt;50s&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="n">facility</span> <span class="o">=</span> <span class="n">facility</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;SampleInfo/Facility = </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">facility</span>
                
        <span class="k">if</span> <span class="n">ole</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">&#39;SampleInfo/SampleID&#39;</span><span class="p">):</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="s">&#39;SampleInfo/SampleID&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">&#39;&lt;50s&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="n">sample</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;SampleInfo/SampleID = </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">sample</span>
                
                
        <span class="c">#This is an array of date+time stamps....</span>
        <span class="k">if</span> <span class="n">ole</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">&#39;ImageInfo/Date&#39;</span><span class="p">):</span>   
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="s">&#39;ImageInfo/Date&#39;</span><span class="p">)</span>       
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">date</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">&#39;&lt;40s7200s&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="n">date</span> <span class="o">=</span> <span class="n">date</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;ImageInfo/Date = </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">date</span>    
                
        <span class="n">datasize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ole</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">&#39;ImageInfo/NoOfImages&#39;</span><span class="p">):</span>                  
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="s">&#39;ImageInfo/NoOfImages&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">nev</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">&#39;&lt;I&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;ImageInfo/NoOfImages = </span><span class="si">%i</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">nev</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  
            <span class="n">nimgs</span> <span class="o">=</span> <span class="n">nev</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">datasize</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">nimgs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_ev</span> <span class="o">=</span> <span class="n">datasize</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                
        <span class="k">if</span> <span class="n">ole</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">&#39;ImageInfo/ImageWidth&#39;</span><span class="p">):</span>                 
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="s">&#39;ImageInfo/ImageWidth&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">nev</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">&#39;&lt;I&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;ImageInfo/ImageWidth = </span><span class="si">%i</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">nev</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  
            <span class="n">datasize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">nev</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_cols</span> <span class="o">=</span> <span class="n">datasize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                
        <span class="k">if</span> <span class="n">ole</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">&#39;ImageInfo/ImageHeight&#39;</span><span class="p">):</span>                  
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="s">&#39;ImageInfo/ImageHeight&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">nev</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">&#39;&lt;I&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;ImageInfo/ImageHeight = </span><span class="si">%i</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">nev</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  
            <span class="n">datasize</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">nev</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_rows</span> <span class="o">=</span> <span class="n">datasize</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                
        <span class="k">if</span> <span class="n">ole</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">&#39;ImageInfo/Angles&#39;</span><span class="p">):</span>                  
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="s">&#39;ImageInfo/Angles&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">struct_fmt</span> <span class="o">=</span> <span class="s">&quot;&lt;{}f&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nimgs</span><span class="p">)</span>
            <span class="n">angles</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">struct_fmt</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;ImageInfo/Angles: </span><span class="se">\n</span><span class="s"> &quot;</span><span class="p">,</span>  <span class="n">angles</span>  
                
        <span class="k">if</span> <span class="n">ole</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">&#39;ImageInfo/Energy&#39;</span><span class="p">):</span>                  
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="s">&#39;ImageInfo/Energy&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">struct_fmt</span> <span class="o">=</span> <span class="s">&quot;&lt;{}f&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nimgs</span><span class="p">)</span>
            <span class="n">eng</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">struct_fmt</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;ImageInfo/Energy: </span><span class="se">\n</span><span class="s"> &quot;</span><span class="p">,</span>  <span class="n">eng</span>  
            <span class="bp">self</span><span class="o">.</span><span class="n">ev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">eng</span><span class="p">)</span>
                
        <span class="k">if</span> <span class="n">ole</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">&#39;ImageInfo/PixelSize&#39;</span><span class="p">):</span>                  
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="s">&#39;ImageInfo/PixelSize&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">struct_fmt</span> <span class="o">=</span> <span class="s">&#39;&lt;1f&#39;</span>
            <span class="n">pixelsize</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">struct_fmt</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="n">pixelsize</span> <span class="o">=</span> <span class="n">pixelsize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;ImageInfo/PixelSize: </span><span class="si">%f</span><span class="s"> &quot;</span> <span class="o">%</span>  <span class="n">pixelsize</span>  
                
        <span class="k">if</span> <span class="n">ole</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">&#39;ImageInfo/ExpTimes&#39;</span><span class="p">):</span>                  
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="s">&#39;ImageInfo/ExpTimes&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">struct_fmt</span> <span class="o">=</span> <span class="s">&quot;&lt;{}f&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nimgs</span><span class="p">)</span>
            <span class="n">exptimes</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">struct_fmt</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;ImageInfo/ExpTimes: </span><span class="se">\n</span><span class="s"> &quot;</span><span class="p">,</span>  <span class="n">exptimes</span>
            
                
        <span class="c"># 10 float; 5 uint16 (unsigned 16-bit (2-byte) integers)</span>
        <span class="k">if</span> <span class="n">ole</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">&#39;ImageInfo/DataType&#39;</span><span class="p">):</span>                  
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="s">&#39;ImageInfo/DataType&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">struct_fmt</span> <span class="o">=</span> <span class="s">&#39;&lt;1I&#39;</span>
            <span class="n">datatype</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">struct_fmt</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="n">datatype</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">datatype</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;ImageInfo/DataType: </span><span class="si">%f</span><span class="s"> &quot;</span> <span class="o">%</span>  <span class="n">datatype</span>  
         
            
        <span class="bp">self</span><span class="o">.</span><span class="n">absdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_ev</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="c">#Read the images - They are stored in ImageData1, ImageData2... Each</span>
        <span class="c">#folder contains 100 images 1-100, 101-200...           </span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nimgs</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">img_string</span> <span class="o">=</span> <span class="s">&quot;ImageData</span><span class="si">%i</span><span class="s">/Image</span><span class="si">%i</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">i</span><span class="o">/</span><span class="mf">100.0</span><span class="p">),</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">ole</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="n">img_string</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="c"># 10 float; 5 uint16 (unsigned 16-bit (2-byte) integers)</span>
            <span class="k">if</span> <span class="n">datatype</span> <span class="o">==</span> <span class="mi">10</span><span class="p">:</span>
                <span class="n">struct_fmt</span> <span class="o">=</span> <span class="s">&quot;&lt;{}f&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_cols</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_rows</span><span class="p">)</span>
                <span class="n">imgdata</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">struct_fmt</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">datatype</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>                   
                <span class="n">struct_fmt</span> <span class="o">=</span> <span class="s">&quot;&lt;{}h&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_cols</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_rows</span><span class="p">)</span>
                <span class="n">imgdata</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">struct_fmt</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>                            
                <span class="k">print</span> <span class="s">&quot;Wrong data type&quot;</span>
                <span class="k">return</span>
                    
            <span class="bp">self</span><span class="o">.</span><span class="n">absdata</span><span class="p">[:,:,</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">imgdata</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_rows</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;F&#39;</span><span class="p">)</span>
                
        <span class="n">ole</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                
        <span class="c">#Fill the data structure with data: </span>
        <span class="n">ds</span><span class="o">.</span><span class="n">implements</span> <span class="o">=</span> <span class="s">&#39;information:exchange:spectromicroscopy&#39;</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">version</span> <span class="o">=</span> <span class="s">&#39;1.0&#39;</span>
        
        
        <span class="n">ds</span><span class="o">.</span><span class="n">information</span><span class="o">.</span><span class="n">file_creation_datetime</span> <span class="o">=</span> <span class="n">date</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">information</span><span class="o">.</span><span class="n">comment</span> <span class="o">=</span> <span class="s">&#39;Converted from .txrm (Xradia file format)&#39;</span><span class="p">,</span>
        

        <span class="n">ds</span><span class="o">.</span><span class="n">information</span><span class="o">.</span><span class="n">experimenter</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">analyst</span>
        
        <span class="n">ds</span><span class="o">.</span><span class="n">information</span><span class="o">.</span><span class="n">sample</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">sample</span>
        
        <span class="n">ds</span><span class="o">.</span><span class="n">exchange</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">absdata</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">exchange</span><span class="o">.</span><span class="n">data_signal</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">exchange</span><span class="o">.</span><span class="n">data_axes</span><span class="o">=</span><span class="s">&#39;x:y&#39;</span>
        
        <span class="n">ds</span><span class="o">.</span><span class="n">exchange</span><span class="o">.</span><span class="n">energy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ev</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">exchange</span><span class="o">.</span><span class="n">energy_units</span> <span class="o">=</span> <span class="s">&#39;ev&#39;</span>
        
        
        <span class="c">#Since we do not have a scanning microscope we fill the x_dist and y_dist from pixel_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_cols</span><span class="p">))</span><span class="o">*</span><span class="n">pixelsize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_rows</span><span class="p">))</span><span class="o">*</span><span class="n">pixelsize</span>
    
        <span class="n">ds</span><span class="o">.</span><span class="n">exchange</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_dist</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">exchange</span><span class="o">.</span><span class="n">x_units</span> <span class="o">=</span> <span class="s">&#39;um&#39;</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">exchange</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_dist</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">exchange</span><span class="o">.</span><span class="n">y_units</span> <span class="o">=</span> <span class="s">&#39;um&#39;</span>    
        
        <span class="n">ds</span><span class="o">.</span><span class="n">exchange</span><span class="o">.</span><span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span>

        <span class="n">ds</span><span class="o">.</span><span class="n">spectromicroscopy</span><span class="o">.</span><span class="n">data_dwell</span> <span class="o">=</span> <span class="n">exptimes</span> 
        
        
        <span class="bp">self</span><span class="o">.</span><span class="n">data_dwell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_ev</span><span class="p">))</span><span class="o">*</span><span class="n">exptimes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
          
          
        <span class="k">return</span>
    
    
    
    </div></div>
<span class="sd">&quot;&quot;&quot;-----------------------------------------------------------------------&quot;&quot;&quot;</span>   
<span class="sd">&quot;&quot;&quot; The following class is used to open Microsoft Structured Storage files&quot;&quot;&quot;</span>
<span class="c">#--- LICENSE ------------------------------------------------------------------</span>

<span class="c"># OleFileIO_PL is an improved version of the OleFileIO module from the</span>
<span class="c"># Python Imaging Library (PIL).</span>

<span class="c"># OleFileIO_PL changes are Copyright (c) 2005-2010 by Philippe Lagadec</span>
<span class="c">#</span>
<span class="c"># The Python Imaging Library (PIL) is</span>
<span class="c">#    Copyright (c) 1997-2005 by Secret Labs AB</span>
<span class="c">#    Copyright (c) 1995-2005 by Fredrik Lundh</span>
<span class="c">#</span>


<span class="c">#------------------------------------------------------------------------------</span>

<span class="kn">import</span> <span class="nn">string</span><span class="o">,</span> <span class="nn">StringIO</span><span class="o">,</span> <span class="nn">struct</span><span class="o">,</span> <span class="nn">array</span><span class="o">,</span> <span class="nn">os.path</span><span class="o">,</span> <span class="nn">sys</span>

<span class="c">#[PL] workaround to fix an issue with array item size on 64 bits systems:</span>
<span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s">&#39;L&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">itemsize</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
    <span class="c"># on 32 bits platforms, long integers in an array are 32 bits:</span>
    <span class="n">UINT32</span> <span class="o">=</span> <span class="s">&#39;L&#39;</span>
<span class="k">elif</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s">&#39;I&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">itemsize</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
    <span class="c"># on 64 bits platforms, integers in an array are 32 bits:</span>
    <span class="n">UINT32</span> <span class="o">=</span> <span class="s">&#39;I&#39;</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="s">&#39;Need to fix a bug with 32 bit arrays, please contact author...&#39;</span>



<span class="c"># Experimental setting: if True, OLE filenames will be kept in Unicode</span>
<span class="c"># if False (default PIL behaviour), all filenames are converted to Latin-1.</span>
<span class="n">KEEP_UNICODE_NAMES</span> <span class="o">=</span> <span class="bp">True</span>

<span class="c"># DEBUG display mode: False by default, use set_debug_mode() or &quot;-d&quot; on</span>
<span class="c"># command line to change it.</span>
<span class="n">DEBUG_MODE</span> <span class="o">=</span> <span class="bp">False</span>


<span class="n">MAGIC</span> <span class="o">=</span> <span class="s">&#39;</span><span class="se">\320\317\021\340\241\261\032\341</span><span class="s">&#39;</span>

<span class="c"># added constants for Sector IDs (from AAF specifications)</span>
<span class="n">MAXREGSECT</span> <span class="o">=</span> <span class="mh">0xFFFFFFFA</span><span class="n">L</span><span class="p">;</span> <span class="c"># maximum SECT</span>
<span class="n">DIFSECT</span>    <span class="o">=</span> <span class="mh">0xFFFFFFFC</span><span class="n">L</span><span class="p">;</span> <span class="c"># (-4) denotes a DIFAT sector in a FAT</span>
<span class="n">FATSECT</span>    <span class="o">=</span> <span class="mh">0xFFFFFFFD</span><span class="n">L</span><span class="p">;</span> <span class="c"># (-3) denotes a FAT sector in a FAT</span>
<span class="n">ENDOFCHAIN</span> <span class="o">=</span> <span class="mh">0xFFFFFFFE</span><span class="n">L</span><span class="p">;</span> <span class="c"># (-2) end of a virtual stream chain</span>
<span class="n">FREESECT</span>   <span class="o">=</span> <span class="mh">0xFFFFFFFF</span><span class="n">L</span><span class="p">;</span> <span class="c"># (-1) unallocated sector</span>

<span class="c">#[PL]: added constants for Directory Entry IDs (from AAF specifications)</span>
<span class="n">MAXREGSID</span>  <span class="o">=</span> <span class="mh">0xFFFFFFFA</span><span class="n">L</span><span class="p">;</span> <span class="c"># maximum directory entry ID</span>
<span class="n">NOSTREAM</span>   <span class="o">=</span> <span class="mh">0xFFFFFFFF</span><span class="n">L</span><span class="p">;</span> <span class="c"># (-1) unallocated directory entry</span>

<span class="c">#[PL] object types in storage (from AAF specifications)</span>
<span class="n">STGTY_EMPTY</span>     <span class="o">=</span> <span class="mi">0</span> <span class="c"># empty directory entry (according to OpenOffice.org doc)</span>
<span class="n">STGTY_STORAGE</span>   <span class="o">=</span> <span class="mi">1</span> <span class="c"># element is a storage object</span>
<span class="n">STGTY_STREAM</span>    <span class="o">=</span> <span class="mi">2</span> <span class="c"># element is a stream object</span>
<span class="n">STGTY_LOCKBYTES</span> <span class="o">=</span> <span class="mi">3</span> <span class="c"># element is an ILockBytes object</span>
<span class="n">STGTY_PROPERTY</span>  <span class="o">=</span> <span class="mi">4</span> <span class="c"># element is an IPropertyStorage object</span>
<span class="n">STGTY_ROOT</span>      <span class="o">=</span> <span class="mi">5</span> <span class="c"># element is a root storage</span>


<span class="c">#</span>
<span class="c"># --------------------------------------------------------------------</span>
<span class="c"># property types</span>

<span class="n">VT_EMPTY</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">VT_NULL</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">VT_I2</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span> <span class="n">VT_I4</span><span class="o">=</span><span class="mi">3</span><span class="p">;</span> <span class="n">VT_R4</span><span class="o">=</span><span class="mi">4</span><span class="p">;</span> <span class="n">VT_R8</span><span class="o">=</span><span class="mi">5</span><span class="p">;</span> <span class="n">VT_CY</span><span class="o">=</span><span class="mi">6</span><span class="p">;</span>
<span class="n">VT_DATE</span><span class="o">=</span><span class="mi">7</span><span class="p">;</span> <span class="n">VT_BSTR</span><span class="o">=</span><span class="mi">8</span><span class="p">;</span> <span class="n">VT_DISPATCH</span><span class="o">=</span><span class="mi">9</span><span class="p">;</span> <span class="n">VT_ERROR</span><span class="o">=</span><span class="mi">10</span><span class="p">;</span> <span class="n">VT_BOOL</span><span class="o">=</span><span class="mi">11</span><span class="p">;</span>
<span class="n">VT_VARIANT</span><span class="o">=</span><span class="mi">12</span><span class="p">;</span> <span class="n">VT_UNKNOWN</span><span class="o">=</span><span class="mi">13</span><span class="p">;</span> <span class="n">VT_DECIMAL</span><span class="o">=</span><span class="mi">14</span><span class="p">;</span> <span class="n">VT_I1</span><span class="o">=</span><span class="mi">16</span><span class="p">;</span> <span class="n">VT_UI1</span><span class="o">=</span><span class="mi">17</span><span class="p">;</span>
<span class="n">VT_UI2</span><span class="o">=</span><span class="mi">18</span><span class="p">;</span> <span class="n">VT_UI4</span><span class="o">=</span><span class="mi">19</span><span class="p">;</span> <span class="n">VT_I8</span><span class="o">=</span><span class="mi">20</span><span class="p">;</span> <span class="n">VT_UI8</span><span class="o">=</span><span class="mi">21</span><span class="p">;</span> <span class="n">VT_INT</span><span class="o">=</span><span class="mi">22</span><span class="p">;</span> <span class="n">VT_UINT</span><span class="o">=</span><span class="mi">23</span><span class="p">;</span>
<span class="n">VT_VOID</span><span class="o">=</span><span class="mi">24</span><span class="p">;</span> <span class="n">VT_HRESULT</span><span class="o">=</span><span class="mi">25</span><span class="p">;</span> <span class="n">VT_PTR</span><span class="o">=</span><span class="mi">26</span><span class="p">;</span> <span class="n">VT_SAFEARRAY</span><span class="o">=</span><span class="mi">27</span><span class="p">;</span> <span class="n">VT_CARRAY</span><span class="o">=</span><span class="mi">28</span><span class="p">;</span>
<span class="n">VT_USERDEFINED</span><span class="o">=</span><span class="mi">29</span><span class="p">;</span> <span class="n">VT_LPSTR</span><span class="o">=</span><span class="mi">30</span><span class="p">;</span> <span class="n">VT_LPWSTR</span><span class="o">=</span><span class="mi">31</span><span class="p">;</span> <span class="n">VT_FILETIME</span><span class="o">=</span><span class="mi">64</span><span class="p">;</span>
<span class="n">VT_BLOB</span><span class="o">=</span><span class="mi">65</span><span class="p">;</span> <span class="n">VT_STREAM</span><span class="o">=</span><span class="mi">66</span><span class="p">;</span> <span class="n">VT_STORAGE</span><span class="o">=</span><span class="mi">67</span><span class="p">;</span> <span class="n">VT_STREAMED_OBJECT</span><span class="o">=</span><span class="mi">68</span><span class="p">;</span>
<span class="n">VT_STORED_OBJECT</span><span class="o">=</span><span class="mi">69</span><span class="p">;</span> <span class="n">VT_BLOB_OBJECT</span><span class="o">=</span><span class="mi">70</span><span class="p">;</span> <span class="n">VT_CF</span><span class="o">=</span><span class="mi">71</span><span class="p">;</span> <span class="n">VT_CLSID</span><span class="o">=</span><span class="mi">72</span><span class="p">;</span>
<span class="n">VT_VECTOR</span><span class="o">=</span><span class="mh">0x1000</span><span class="p">;</span>

<span class="c"># map property id to name (for debugging purposes)</span>

<span class="n">VT</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">keyword</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;VT_&quot;</span><span class="p">:</span>
        <span class="n">VT</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">keyword</span>

<span class="c">#</span>
<span class="c"># --------------------------------------------------------------------</span>


<span class="c">#Defect levels to classify parsing errors - see OleFileIO._raise_defect()</span>
<span class="n">DEFECT_UNSURE</span> <span class="o">=</span>    <span class="mi">10</span>    <span class="c"># a case which looks weird, but not sure it&#39;s a defect</span>
<span class="n">DEFECT_POTENTIAL</span> <span class="o">=</span> <span class="mi">20</span>    <span class="c"># a potential defect</span>
<span class="n">DEFECT_INCORRECT</span> <span class="o">=</span> <span class="mi">30</span>    <span class="c"># an error according to specifications, but parsing</span>
                         <span class="c"># can go on</span>
<span class="n">DEFECT_FATAL</span> <span class="o">=</span>     <span class="mi">40</span>    <span class="c"># an error which cannot be ignored, parsing is</span>
                         <span class="c"># impossible</span>


<span class="c">#--- FUNCTIONS ----------------------------------------------------------------</span>

<div class="viewcode-block" id="isOleFile"><a class="viewcode-back" href="../../../../resources/dataexchange.xtomo.formats.xradia_xrm.html#dataexchange.xtomo.formats.xradia_xrm.isOleFile">[docs]</a><span class="k">def</span> <span class="nf">isOleFile</span> <span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Test if file is an OLE container (according to its header).</span>
<span class="sd">    filename: file name or path (str, unicode)</span>
<span class="sd">    return: True if OLE, False otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;rb&#39;</span><span class="p">)</span>
    <span class="n">header</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">MAGIC</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">header</span> <span class="o">==</span> <span class="n">MAGIC</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>

</div>
<div class="viewcode-block" id="i16"><a class="viewcode-back" href="../../../../resources/dataexchange.xtomo.formats.xradia_xrm.html#dataexchange.xtomo.formats.xradia_xrm.i16">[docs]</a><span class="k">def</span> <span class="nf">i16</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">o</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a 2-bytes (16 bits) string to an integer.</span>

<span class="sd">    c: string containing bytes to convert</span>
<span class="sd">    o: offset of bytes to convert in string</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">o</span><span class="p">])</span><span class="o">+</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">o</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="i32"><a class="viewcode-back" href="../../../../resources/dataexchange.xtomo.formats.xradia_xrm.html#dataexchange.xtomo.formats.xradia_xrm.i32">[docs]</a><span class="k">def</span> <span class="nf">i32</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">o</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a 4-bytes (32 bits) string to an integer.</span>

<span class="sd">    c: string containing bytes to convert</span>
<span class="sd">    o: offset of bytes to convert in string</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">o</span><span class="p">])</span><span class="o">+</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">o</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">o</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span><span class="o">&lt;&lt;</span><span class="mi">16</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">o</span><span class="o">+</span><span class="mi">3</span><span class="p">])</span><span class="o">&lt;&lt;</span><span class="mi">24</span><span class="p">))</span>
    <span class="c"># [PL]: added int() because &quot;&lt;&lt;&quot; gives long int since Python 2.4</span>

</div>
<span class="k">def</span> <span class="nf">_clsid</span><span class="p">(</span><span class="n">clsid</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a CLSID to a human-readable string.</span>
<span class="sd">    clsid: string of length 16.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">clsid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">16</span>
    <span class="k">if</span> <span class="n">clsid</span> <span class="o">==</span> <span class="s">&quot;</span><span class="se">\0</span><span class="s">&quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">clsid</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;&quot;</span>
    <span class="k">return</span> <span class="p">((</span><span class="s">&quot;</span><span class="si">%08X</span><span class="s">-</span><span class="si">%04X</span><span class="s">-</span><span class="si">%04X</span><span class="s">-</span><span class="si">%02X%02X</span><span class="s">-&quot;</span> <span class="o">+</span> <span class="s">&quot;</span><span class="si">%02X</span><span class="s">&quot;</span> <span class="o">*</span> <span class="mi">6</span><span class="p">)</span> <span class="o">%</span>
            <span class="p">((</span><span class="n">i32</span><span class="p">(</span><span class="n">clsid</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">i16</span><span class="p">(</span><span class="n">clsid</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">i16</span><span class="p">(</span><span class="n">clsid</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span> <span class="o">+</span>
            <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">ord</span><span class="p">,</span> <span class="n">clsid</span><span class="p">[</span><span class="mi">8</span><span class="p">:</span><span class="mi">16</span><span class="p">]))))</span>



<span class="c"># UNICODE support for Old Python versions:</span>
<span class="c"># (necessary to handle storages/streams names which use Unicode)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="c"># is Unicode supported ?</span>
    <span class="nb">unicode</span>

    <span class="k">def</span> <span class="nf">_unicode</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s">&#39;replace&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Map unicode string to Latin 1. (Python with Unicode support)</span>

<span class="sd">        s: UTF-16LE unicode string to convert to Latin-1</span>
<span class="sd">        errors: &#39;replace&#39;, &#39;ignore&#39; or &#39;strict&#39;. See Python doc for unicode()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c"># First the string is converted to plain Unicode:</span>
            <span class="c"># (assuming it is encoded as UTF-16 little-endian)</span>
            <span class="k">print</span> <span class="s">&quot;unicode s.decode&quot;</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">&#39;UTF-16LE&#39;</span><span class="p">,</span> <span class="n">errors</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">KEEP_UNICODE_NAMES</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">u</span>
            <span class="k">else</span><span class="p">:</span>
                
                <span class="c"># Second the unicode string is converted to Latin-1</span>
                <span class="k">return</span> <span class="n">u</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">&#39;latin_1&#39;</span><span class="p">,</span> <span class="n">errors</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="c"># there was an error during Unicode to Latin-1 conversion:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">,</span> <span class="s">&#39;incorrect Unicode name&#39;</span>

<span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">_unicode</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s">&#39;replace&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Map unicode string to Latin 1. (Python without native Unicode support)</span>

<span class="sd">        s: UTF-16LE unicode string to convert to Latin-1</span>
<span class="sd">        errors: &#39;replace&#39;, &#39;ignore&#39; or &#39;strict&#39;. (ignored in this version)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">print</span> <span class="s">&quot;unicode filter&quot;</span>
        <span class="c"># If the unicode function does not exist, we assume this is an old</span>
        <span class="c"># Python version without Unicode support.</span>
        <span class="c"># Null bytes are simply removed (this only works with usual Latin-1</span>
        <span class="c"># strings which do not contain unicode characters&gt;256):</span>
        <span class="k">return</span> <span class="nb">filter</span><span class="p">(</span><span class="nb">ord</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>




<span class="c">#=== CLASSES ==================================================================</span>

<span class="c">#--- _OleStream ---------------------------------------------------------------</span>

<span class="k">class</span> <span class="nc">_OleStream</span><span class="p">(</span><span class="n">StringIO</span><span class="o">.</span><span class="n">StringIO</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    OLE2 Stream</span>

<span class="sd">    Returns a read-only file object which can be used to read</span>
<span class="sd">    the contents of a OLE stream (instance of the StringIO class).</span>
<span class="sd">    To open a stream, use the openstream method in the OleFile class.</span>

<span class="sd">    This function can be used with either ordinary streams,</span>
<span class="sd">    or ministreams, depending on the offset, sectorsize, and</span>
<span class="sd">    fat table arguments.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        - size: actual size of data stream, after it was opened.</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">sect</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">sectorsize</span><span class="p">,</span> <span class="n">fat</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor for _OleStream class.</span>

<span class="sd">        fp        : file object, the OLE container or the MiniFAT stream</span>
<span class="sd">        sect      : sector index of first sector in the stream</span>
<span class="sd">        size      : total size of the stream</span>
<span class="sd">        offset    : offset in bytes for the first FAT or MiniFAT sector</span>
<span class="sd">        sectorsize: size of one sector</span>
<span class="sd">        fat       : array/list of sector indexes (FAT or MiniFAT)</span>
<span class="sd">        return    : a StringIO instance containing the OLE stream</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">DEBUG_MODE</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;_OleStream.__init__:</span><span class="se">\n</span><span class="s">&#39;</span>
            <span class="k">print</span> <span class="s">&#39;  sect=</span><span class="si">%d</span><span class="s"> (</span><span class="si">%X</span><span class="s">), size=</span><span class="si">%d</span><span class="s">, offset=</span><span class="si">%d</span><span class="s">, sectorsize=</span><span class="si">%d</span><span class="s">, len(fat)=</span><span class="si">%d</span><span class="s">, fp=</span><span class="si">%s</span><span class="s"> </span><span class="se">\n\n</span><span class="s">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">sect</span><span class="p">,</span><span class="n">sect</span><span class="p">,</span><span class="n">size</span><span class="p">,</span><span class="n">offset</span><span class="p">,</span><span class="n">sectorsize</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">fat</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span>
        <span class="c"># for debugging messages, size of file where stream is read:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">StringIO</span><span class="o">.</span><span class="n">StringIO</span><span class="p">):</span>
            <span class="n">filesize</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fp</span><span class="o">.</span><span class="n">getvalue</span><span class="p">())</span>   <span class="c"># file in MiniFAT</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">filesize</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getsize</span><span class="p">(</span><span class="n">fp</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="c"># file on disk</span>
        <span class="c">#[PL] To detect malformed documents with FAT loops, we compute the</span>
        <span class="c"># expected number of sectors in the stream:</span>
        <span class="n">unknown_size</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">size</span><span class="o">==</span><span class="mh">0x7FFFFFFF</span><span class="p">:</span>
            <span class="c"># this is the case when called from OleFileIO._open(), and stream</span>
            <span class="c"># size is not known in advance (for example when reading the</span>
            <span class="c"># Directory stream). Then we can only guess maximum size:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fat</span><span class="p">)</span><span class="o">*</span><span class="n">sectorsize</span>
            <span class="c"># and we keep a record that size was unknown:</span>
            <span class="n">unknown_size</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="n">DEBUG_MODE</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;  stream with UNKNOWN SIZE&#39;</span>
        <span class="n">nb_sectors</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="p">(</span><span class="n">sectorsize</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="n">sectorsize</span>
        <span class="c">#print &#39;nb_sectors = %d&#39; % nb_sectors</span>
        <span class="c"># This number should (at least) be less than the total number of</span>
        <span class="c"># sectors in the given FAT:</span>
        <span class="k">if</span> <span class="n">nb_sectors</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">fat</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">,</span> <span class="s">&#39;malformed OLE document, stream too large&#39;</span>
        <span class="c"># optimization(?): data is first a list of strings, and join() is called</span>
        <span class="c"># at the end to concatenate all in one string.</span>
        <span class="c"># (this may not be really useful with recent Python versions)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c"># if size is zero, then first sector index should be ENDOFCHAIN:</span>
        <span class="k">if</span> <span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">sect</span> <span class="o">!=</span> <span class="n">ENDOFCHAIN</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">DEBUG_MODE</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&#39;size == 0 and sect != ENDOFCHAIN:&#39;</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">,</span> <span class="s">&#39;incorrect OLE sector index for empty stream&#39;</span>
        <span class="c">#[ A fixed-length for loop is used instead of an undefined while</span>
        <span class="c"># loop to avoid DoS attacks:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nb_sectors</span><span class="p">):</span>
            <span class="c"># Sector index may be ENDOFCHAIN, but only if size was unknown</span>
            <span class="k">if</span> <span class="n">sect</span> <span class="o">==</span> <span class="n">ENDOFCHAIN</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">unknown_size</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># else this means that the stream is smaller than declared:</span>
                    <span class="k">if</span> <span class="n">DEBUG_MODE</span><span class="p">:</span>
                        <span class="k">print</span> <span class="s">&#39;sect=ENDOFCHAIN before expected size&#39;</span>
                    <span class="k">raise</span> <span class="ne">IOError</span><span class="p">,</span> <span class="s">&#39;incomplete OLE stream&#39;</span>
            <span class="c"># sector index should be within FAT:</span>
            <span class="k">if</span> <span class="n">sect</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">sect</span><span class="o">&gt;=</span><span class="nb">len</span><span class="p">(</span><span class="n">fat</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">DEBUG_MODE</span><span class="p">:</span>
                    <span class="k">print</span> <span class="s">&#39;sect=</span><span class="si">%d</span><span class="s"> (</span><span class="si">%X</span><span class="s">) / len(fat)=</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sect</span><span class="p">,</span> <span class="n">sect</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fat</span><span class="p">))</span>
                    <span class="k">print</span> <span class="s">&#39;i=</span><span class="si">%d</span><span class="s"> / nb_sectors=</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">nb_sectors</span><span class="p">)</span>

                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">,</span> <span class="s">&#39;incorrect OLE FAT, sector index out of range&#39;</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">fp</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">sectorsize</span> <span class="o">*</span> <span class="n">sect</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">DEBUG_MODE</span><span class="p">:</span>
                    <span class="k">print</span> <span class="s">&#39;sect=</span><span class="si">%d</span><span class="s">, seek=</span><span class="si">%d</span><span class="s">, filesize=</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sect</span><span class="p">,</span> <span class="n">offset</span><span class="o">+</span><span class="n">sectorsize</span><span class="o">*</span><span class="n">sect</span><span class="p">,</span> <span class="n">filesize</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">,</span> <span class="s">&#39;OLE sector index out of range&#39;</span>
            <span class="n">sector_data</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">sectorsize</span><span class="p">)</span>
            <span class="c"># [PL] check if there was enough data:</span>
            <span class="c"># Note: if sector is the last of the file, sometimes it is not a</span>
            <span class="c"># complete sector (of 512 or 4K), so we may read less than</span>
            <span class="c"># sectorsize.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sector_data</span><span class="p">)</span><span class="o">!=</span><span class="n">sectorsize</span> <span class="ow">and</span> <span class="n">sect</span><span class="o">!=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fat</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">DEBUG_MODE</span><span class="p">:</span>
                    <span class="k">print</span> <span class="s">&#39;sect=</span><span class="si">%d</span><span class="s"> / len(fat)=</span><span class="si">%d</span><span class="s">, seek=</span><span class="si">%d</span><span class="s"> / filesize=</span><span class="si">%d</span><span class="s">, len read=</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sect</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fat</span><span class="p">),</span> <span class="n">offset</span><span class="o">+</span><span class="n">sectorsize</span><span class="o">*</span><span class="n">sect</span><span class="p">,</span> <span class="n">filesize</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sector_data</span><span class="p">))</span>
                    <span class="k">print</span> <span class="s">&#39;seek+len(read)=</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">offset</span><span class="o">+</span><span class="n">sectorsize</span><span class="o">*</span><span class="n">sect</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">sector_data</span><span class="p">))</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">,</span> <span class="s">&#39;incomplete OLE sector&#39;</span>
            <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sector_data</span><span class="p">)</span>
            <span class="c"># jump to next sector in the FAT:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">sect</span> <span class="o">=</span> <span class="n">fat</span><span class="p">[</span><span class="n">sect</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="c">#  if pointer is out of the FAT an exception is raised</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">,</span> <span class="s">&#39;incorrect OLE FAT, sector index out of range&#39;</span>
        <span class="c"># Last sector should be a &quot;end of chain&quot; marker:</span>
        <span class="k">if</span> <span class="n">sect</span> <span class="o">!=</span> <span class="n">ENDOFCHAIN</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">,</span> <span class="s">&#39;incorrect last sector index in OLE stream&#39;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
        <span class="c"># Data is truncated to the actual stream size:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span><span class="n">size</span><span class="p">]</span>
            <span class="c"># actual stream size is stored for future use:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="k">elif</span> <span class="n">unknown_size</span><span class="p">:</span>
            <span class="c"># actual stream size was not known, now we know the size of read</span>
            <span class="c"># data:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># read data is less than expected:</span>
            <span class="k">if</span> <span class="n">DEBUG_MODE</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&#39;len(data)=</span><span class="si">%d</span><span class="s">, size=</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">size</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">,</span> <span class="s">&#39;OLE stream size is less than declared&#39;</span>
        <span class="c"># when all data is read in memory, StringIO constructor is called</span>
        <span class="n">StringIO</span><span class="o">.</span><span class="n">StringIO</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="c"># Then the _OleStream object can be used as a read-only file object.</span>


<span class="c">#--- _OleDirectoryEntry -------------------------------------------------------</span>

<span class="k">class</span> <span class="nc">_OleDirectoryEntry</span><span class="p">:</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    OLE2 Directory Entry</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c">#[PL] parsing code moved from OleFileIO.loaddirectory</span>

    <span class="c"># struct to parse directory entries:</span>
    <span class="c"># &lt;: little-endian byte order</span>
    <span class="c"># 64s: string containing entry name in unicode (max 31 chars) + null char</span>
    <span class="c"># H: uint16, number of bytes used in name buffer, including null = (len+1)*2</span>
    <span class="c"># B: uint8, dir entry type (between 0 and 5)</span>
    <span class="c"># B: uint8, color: 0=black, 1=red</span>
    <span class="c"># I: uint32, index of left child node in the red-black tree, NOSTREAM if none</span>
    <span class="c"># I: uint32, index of right child node in the red-black tree, NOSTREAM if none</span>
    <span class="c"># I: uint32, index of child root node if it is a storage, else NOSTREAM</span>
    <span class="c"># 16s: CLSID, unique identifier (only used if it is a storage)</span>
    <span class="c"># I: uint32, user flags</span>
    <span class="c"># 8s: uint64, creation timestamp or zero</span>
    <span class="c"># 8s: uint64, modification timestamp or zero</span>
    <span class="c"># I: uint32, SID of first sector if stream or ministream, SID of 1st sector</span>
    <span class="c">#    of stream containing ministreams if root entry, 0 otherwise</span>
    <span class="c"># I: uint32, total stream size in bytes if stream (low 32 bits), 0 otherwise</span>
    <span class="c"># I: uint32, total stream size in bytes if stream (high 32 bits), 0 otherwise</span>
    <span class="n">STRUCT_DIRENTRY</span> <span class="o">=</span> <span class="s">&#39;&lt;64sHBBIII16sI8s8sIII&#39;</span>
    <span class="c"># size of a directory entry: 128 bytes</span>
    <span class="n">DIRENTRY_SIZE</span> <span class="o">=</span> <span class="mi">128</span>
    <span class="k">assert</span> <span class="n">struct</span><span class="o">.</span><span class="n">calcsize</span><span class="p">(</span><span class="n">STRUCT_DIRENTRY</span><span class="p">)</span> <span class="o">==</span> <span class="n">DIRENTRY_SIZE</span>


    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">sid</span><span class="p">,</span> <span class="n">olefile</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor for an _OleDirectoryEntry object.</span>
<span class="sd">        Parses a 128-bytes entry from the OLE Directory stream.</span>

<span class="sd">        entry  : string (must be 128 bytes long)</span>
<span class="sd">        sid    : index of this directory entry in the OLE file directory</span>
<span class="sd">        olefile: OleFileIO containing this directory entry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sid</span> <span class="o">=</span> <span class="n">sid</span>
        <span class="c"># ref to olefile is stored for future use</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">olefile</span> <span class="o">=</span> <span class="n">olefile</span>
        <span class="c"># kids is a list of children entries, if this entry is a storage:</span>
        <span class="c"># (list of _OleDirectoryEntry objects)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c"># kids_dict is a dictionary of children entries, indexed by their</span>
        <span class="c"># name in lowercase: used to quickly find an entry, and to detect</span>
        <span class="c"># duplicates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kids_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c"># flag used to detect if the entry is referenced more than once in</span>
        <span class="c"># directory:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">used</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="c"># decode DirEntry</span>
        <span class="p">(</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">namelength</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">entry_type</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">color</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sid_left</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sid_right</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sid_child</span><span class="p">,</span>
            <span class="n">clsid</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dwUserFlags</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">createTime</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">modifyTime</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">isectStart</span><span class="p">,</span>
            <span class="n">sizeLow</span><span class="p">,</span>
            <span class="n">sizeHigh</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">_OleDirectoryEntry</span><span class="o">.</span><span class="n">STRUCT_DIRENTRY</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">entry_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">STGTY_ROOT</span><span class="p">,</span> <span class="n">STGTY_STORAGE</span><span class="p">,</span> <span class="n">STGTY_STREAM</span><span class="p">,</span> <span class="n">STGTY_EMPTY</span><span class="p">]:</span>
            <span class="n">olefile</span><span class="o">.</span><span class="n">_raise_defect</span><span class="p">(</span><span class="n">DEFECT_INCORRECT</span><span class="p">,</span> <span class="s">&#39;unhandled OLE storage type&#39;</span><span class="p">)</span>
        <span class="c"># only first directory entry can (and should) be root:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">entry_type</span> <span class="o">==</span> <span class="n">STGTY_ROOT</span> <span class="ow">and</span> <span class="n">sid</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">olefile</span><span class="o">.</span><span class="n">_raise_defect</span><span class="p">(</span><span class="n">DEFECT_INCORRECT</span><span class="p">,</span> <span class="s">&#39;duplicate OLE root entry&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sid</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">entry_type</span> <span class="o">!=</span> <span class="n">STGTY_ROOT</span><span class="p">:</span>
            <span class="n">olefile</span><span class="o">.</span><span class="n">_raise_defect</span><span class="p">(</span><span class="n">DEFECT_INCORRECT</span><span class="p">,</span> <span class="s">&#39;incorrect OLE root entry&#39;</span><span class="p">)</span>

        
        <span class="c"># name should be at most 31 unicode characters + null character,</span>
        <span class="c"># so 64 bytes in total (31*2 + 2):</span>
        <span class="k">if</span> <span class="n">namelength</span><span class="o">&gt;</span><span class="mi">64</span><span class="p">:</span>
            <span class="n">olefile</span><span class="o">.</span><span class="n">_raise_defect</span><span class="p">(</span><span class="n">DEFECT_INCORRECT</span><span class="p">,</span> <span class="s">&#39;incorrect DirEntry name length&#39;</span><span class="p">)</span>
            <span class="c"># if exception not raised, namelength is set to the maximum value:</span>
            <span class="n">namelength</span> <span class="o">=</span> <span class="mi">64</span>
        <span class="k">if</span> <span class="n">DEBUG_MODE</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;namelength = &#39;</span><span class="p">,</span> <span class="n">namelength</span>
        <span class="c"># only characters without ending null char are kept:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">[:(</span><span class="n">namelength</span><span class="o">-</span><span class="mi">2</span><span class="p">)]</span>
        <span class="c"># name is converted from unicode to Latin-1:</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="nb">unicode</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="s">&#39;utf-16&#39;</span><span class="p">)</span> 
        
        <span class="k">if</span> <span class="n">DEBUG_MODE</span><span class="p">:</span> 
            <span class="k">print</span> <span class="s">&quot;name = &quot;</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

            <span class="k">print</span> <span class="s">&#39;DirEntry SID=</span><span class="si">%d</span><span class="s">: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sid</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
            <span class="k">print</span> <span class="s">&#39; - type: </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">entry_type</span>
            <span class="k">print</span> <span class="s">&#39; - sect: </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">isectStart</span>
            <span class="k">print</span> <span class="s">&#39; - SID left: </span><span class="si">%d</span><span class="s">, right: </span><span class="si">%d</span><span class="s">, child: </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sid_left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sid_right</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sid_child</span><span class="p">)</span>

        <span class="c"># sizeHigh is only used for 4K sectors, it should be zero for 512 bytes</span>
        <span class="c"># sectors, BUT apparently some implementations set it as 0xFFFFFFFFL, 1</span>
        <span class="c"># or some other value so it cannot be raised as a defect in general:</span>
        <span class="k">if</span> <span class="n">olefile</span><span class="o">.</span><span class="n">sectorsize</span> <span class="o">==</span> <span class="mi">512</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sizeHigh</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">sizeHigh</span> <span class="o">!=</span> <span class="mh">0xFFFFFFFF</span><span class="n">L</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">DEBUG_MODE</span><span class="p">:</span>
                    <span class="k">print</span> <span class="p">(</span><span class="s">&#39;sectorsize=</span><span class="si">%d</span><span class="s">, sizeLow=</span><span class="si">%d</span><span class="s">, sizeHigh=</span><span class="si">%d</span><span class="s"> (</span><span class="si">%X</span><span class="s">)&#39;</span> <span class="o">%</span>
                    <span class="p">(</span><span class="n">olefile</span><span class="o">.</span><span class="n">sectorsize</span><span class="p">,</span> <span class="n">sizeLow</span><span class="p">,</span> <span class="n">sizeHigh</span><span class="p">,</span> <span class="n">sizeHigh</span><span class="p">))</span>
                <span class="n">olefile</span><span class="o">.</span><span class="n">_raise_defect</span><span class="p">(</span><span class="n">DEFECT_UNSURE</span><span class="p">,</span> <span class="s">&#39;incorrect OLE stream size&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">sizeLow</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">sizeLow</span> <span class="o">+</span> <span class="p">(</span><span class="nb">long</span><span class="p">(</span><span class="n">sizeHigh</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">32</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">DEBUG_MODE</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39; - size: </span><span class="si">%d</span><span class="s"> (sizeLow=</span><span class="si">%d</span><span class="s">, sizeHigh=</span><span class="si">%d</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">sizeLow</span><span class="p">,</span> <span class="n">sizeHigh</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">clsid</span> <span class="o">=</span> <span class="n">_clsid</span><span class="p">(</span><span class="n">clsid</span><span class="p">)</span>
        <span class="c"># a storage should have a null size, BUT some implementations such as</span>
        <span class="c"># Word 8 for Mac seem to allow non-null values =&gt; Potential defect:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">entry_type</span> <span class="o">==</span> <span class="n">STGTY_STORAGE</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">olefile</span><span class="o">.</span><span class="n">_raise_defect</span><span class="p">(</span><span class="n">DEFECT_POTENTIAL</span><span class="p">,</span> <span class="s">&#39;OLE storage with size&gt;0&#39;</span><span class="p">)</span>
        <span class="c"># check if stream is not already referenced elsewhere:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">entry_type</span> <span class="ow">in</span> <span class="p">(</span><span class="n">STGTY_ROOT</span><span class="p">,</span> <span class="n">STGTY_STREAM</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">olefile</span><span class="o">.</span><span class="n">minisectorcutoff</span> \
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">entry_type</span><span class="o">==</span><span class="n">STGTY_STREAM</span><span class="p">:</span> <span class="c"># only streams can be in MiniFAT</span>
                <span class="c"># ministream object</span>
                <span class="n">minifat</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">minifat</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">olefile</span><span class="o">.</span><span class="n">_check_duplicate_stream</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">isectStart</span><span class="p">,</span> <span class="n">minifat</span><span class="p">)</span>



    <span class="k">def</span> <span class="nf">build_storage_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read and build the red-black tree attached to this _OleDirectoryEntry</span>
<span class="sd">        object, if it is a storage.</span>
<span class="sd">        Note that this method builds a tree of all subentries, so it should</span>
<span class="sd">        only be called for the root object once.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c">#print &#39;build_storage_tree: SID=%d - %s - sid_child=%d&#39;,self.sid, repr(self.name), self.sid_child</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sid_child</span> <span class="o">!=</span> <span class="n">NOSTREAM</span><span class="p">:</span>
            
            <span class="c"># if child SID is not NOSTREAM, then this entry is a storage.</span>
            <span class="c"># Let&#39;s walk through the tree of children to fill the kids list:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">append_kids</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sid_child</span><span class="p">)</span>

            <span class="c"># Note from OpenOffice documentation: the safest way is to</span>
            <span class="c"># recreate the tree because some implementations may store broken</span>
            <span class="c"># red-black trees...</span>

            <span class="c"># in the OLE file, entries are sorted on (length, name).</span>
            <span class="c"># for convenience, we sort them on name instead:</span>
            <span class="c"># (see __cmp__ method in this class)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kids</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">append_kids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child_sid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Walk through red-black tree of children of this directory entry to add</span>
<span class="sd">        all of them to the kids list. (recursive method)</span>

<span class="sd">        child_sid : index of child directory entry to use, or None when called</span>
<span class="sd">                    first time for the root. (only used during recursion)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#[PL] this method was added to use simple recursion instead of a complex</span>
        <span class="c"># algorithm.</span>
        <span class="c"># if this is not a storage or a leaf of the tree, nothing to do:</span>

        <span class="k">if</span> <span class="n">child_sid</span> <span class="o">==</span> <span class="n">NOSTREAM</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="c"># check if child SID is in the proper range:</span>
        <span class="k">if</span> <span class="n">child_sid</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">child_sid</span><span class="o">&gt;=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">olefile</span><span class="o">.</span><span class="n">direntries</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">olefile</span><span class="o">.</span><span class="n">_raise_defect</span><span class="p">(</span><span class="n">DEFECT_FATAL</span><span class="p">,</span> <span class="s">&#39;OLE DirEntry index out of range&#39;</span><span class="p">)</span>
        <span class="c"># get child direntry:</span>
        <span class="n">child</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">olefile</span><span class="o">.</span><span class="n">_load_direntry</span><span class="p">(</span><span class="n">child_sid</span><span class="p">)</span> 
        <span class="k">if</span> <span class="n">DEBUG_MODE</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;name &#39;</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">print</span> <span class="s">&#39;append_kids: child_sid=&#39;</span><span class="p">,</span><span class="n">child</span><span class="o">.</span><span class="n">sid</span>
            <span class="k">print</span> <span class="s">&#39;sid_left&#39;</span><span class="p">,</span><span class="n">child</span><span class="o">.</span><span class="n">sid_left</span>
            <span class="k">print</span> <span class="s">&#39;sid_right&#39;</span><span class="p">,</span><span class="n">child</span><span class="o">.</span><span class="n">sid_right</span>
            <span class="k">print</span> <span class="s">&#39;sid_child&#39;</span><span class="p">,</span> <span class="n">child</span><span class="o">.</span><span class="n">sid_child</span>
        <span class="c"># the directory entries are organized as a red-black tree.</span>
        <span class="c"># (cf. Wikipedia for details)</span>
        <span class="c"># First walk through left side of the tree:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">append_kids</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">sid_left</span><span class="p">)</span>
        <span class="c"># Check if its name is not already used (case-insensitive):</span>
        <span class="n">name_lower</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kids_dict</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">name_lower</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">olefile</span><span class="o">.</span><span class="n">_raise_defect</span><span class="p">(</span><span class="n">DEFECT_INCORRECT</span><span class="p">,</span>
                <span class="s">&quot;Duplicate filename in OLE storage&quot;</span><span class="p">)</span>
        <span class="c"># Then the child_sid _OleDirectoryEntry object is appended to the</span>
        <span class="c"># kids list and dictionary:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kids_dict</span><span class="p">[</span><span class="n">name_lower</span><span class="p">]</span> <span class="o">=</span> <span class="n">child</span>
        <span class="c"># Check if kid was not already referenced in a storage:</span>
        <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">used</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">olefile</span><span class="o">.</span><span class="n">_raise_defect</span><span class="p">(</span><span class="n">DEFECT_INCORRECT</span><span class="p">,</span>
                <span class="s">&#39;OLE Entry referenced more than once&#39;</span><span class="p">)</span>
        <span class="n">child</span><span class="o">.</span><span class="n">used</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="c"># Finally walk through right side of the tree:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">append_kids</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">sid_right</span><span class="p">)</span>
        <span class="c"># Afterwards build kid&#39;s own tree if it&#39;s also a storage:</span>
        <span class="n">child</span><span class="o">.</span><span class="n">build_storage_tree</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">__cmp__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="s">&quot;Compare entries by name&quot;</span>
        <span class="k">return</span> <span class="nb">cmp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tab</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="s">&quot;Dump this entry, and all its subentries (for debug purposes only)&quot;</span>
        <span class="n">TYPES</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;(invalid)&quot;</span><span class="p">,</span> <span class="s">&quot;(storage)&quot;</span><span class="p">,</span> <span class="s">&quot;(stream)&quot;</span><span class="p">,</span> <span class="s">&quot;(lockbytes)&quot;</span><span class="p">,</span>
                 <span class="s">&quot;(property)&quot;</span><span class="p">,</span> <span class="s">&quot;(root)&quot;</span><span class="p">]</span>
        <span class="k">print</span> <span class="s">&quot; &quot;</span><span class="o">*</span><span class="n">tab</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="n">TYPES</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">entry_type</span><span class="p">],</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">entry_type</span> <span class="ow">in</span> <span class="p">(</span><span class="n">STGTY_STREAM</span><span class="p">,</span> <span class="n">STGTY_ROOT</span><span class="p">):</span>
            <span class="k">print</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="s">&quot;bytes&quot;</span><span class="p">,</span>
        <span class="k">print</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">entry_type</span> <span class="ow">in</span> <span class="p">(</span><span class="n">STGTY_STORAGE</span><span class="p">,</span> <span class="n">STGTY_ROOT</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">clsid</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot; &quot;</span><span class="o">*</span><span class="n">tab</span> <span class="o">+</span> <span class="s">&quot;{</span><span class="si">%s</span><span class="s">}&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">clsid</span>

        <span class="k">for</span> <span class="n">kid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kids</span><span class="p">:</span>
            <span class="n">kid</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">tab</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>


<span class="c">#--- OleFileIO ----------------------------------------------------------------</span>

<div class="viewcode-block" id="OleFileIO"><a class="viewcode-back" href="../../../../resources/dataexchange.xtomo.formats.xradia_xrm.html#dataexchange.xtomo.formats.xradia_xrm.OleFileIO">[docs]</a><span class="k">class</span> <span class="nc">OleFileIO</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    OLE container object</span>

<span class="sd">    This class encapsulates the interface to an OLE 2 structured</span>
<span class="sd">    storage file.  Use the {@link listdir} and {@link openstream} methods to</span>
<span class="sd">    access the contents of this file.</span>

<span class="sd">    Object names are given as a list of strings, one for each subentry</span>
<span class="sd">    level.  The root entry should be omitted.  For example, the following</span>
<span class="sd">    code extracts all image streams from a Microsoft Image Composer file:</span>

<span class="sd">        ole = OleFileIO(&quot;fan.mic&quot;)</span>

<span class="sd">        for entry in ole.listdir():</span>
<span class="sd">            if entry[1:2] == &quot;Image&quot;:</span>
<span class="sd">                fin = ole.openstream(entry)</span>
<span class="sd">                fout = open(entry[0:1], &quot;wb&quot;)</span>
<span class="sd">                while 1:</span>
<span class="sd">                    s = fin.read(8192)</span>
<span class="sd">                    if not s:</span>
<span class="sd">                        break</span>
<span class="sd">                    fout.write(s)</span>

<span class="sd">    You can use the viewer application provided with the Python Imaging</span>
<span class="sd">    Library to view the resulting files (which happens to be standard</span>
<span class="sd">    TIFF files).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">raise_defects</span><span class="o">=</span><span class="n">DEFECT_FATAL</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor for OleFileIO class.</span>

<span class="sd">        filename: file to open.</span>
<span class="sd">        raise_defects: minimal level for defects to be raised as exceptions.</span>
<span class="sd">        (use DEFECT_FATAL for a typical application, DEFECT_INCORRECT for a</span>
<span class="sd">        security-oriented application, see source code for details)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_defects_level</span> <span class="o">=</span> <span class="n">raise_defects</span>
        <span class="k">if</span> <span class="n">filename</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_raise_defect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">defect_level</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method should be called for any defect found during file parsing.</span>
<span class="sd">        It may raise an IOError exception according to the minimal level chosen</span>
<span class="sd">        for the OleFileIO object.</span>

<span class="sd">        defect_level: defect level, possible values are:</span>
<span class="sd">            DEFECT_UNSURE    : a case which looks weird, but not sure it&#39;s a defect</span>
<span class="sd">            DEFECT_POTENTIAL : a potential defect</span>
<span class="sd">            DEFECT_INCORRECT : an error according to specifications, but parsing can go on</span>
<span class="sd">            DEFECT_FATAL     : an error which cannot be ignored, parsing is impossible</span>
<span class="sd">        message: string describing the defect, used with raised exception.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># added by [PL]</span>
        <span class="k">if</span> <span class="n">defect_level</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raise_defects_level</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">,</span> <span class="n">message</span>


<div class="viewcode-block" id="OleFileIO.close"><a class="viewcode-back" href="../../../../resources/dataexchange.xtomo.formats.xradia_xrm.html#dataexchange.xtomo.formats.xradia_xrm.OleFileIO.close">[docs]</a>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Close an OLE2 file.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            
</div>
<div class="viewcode-block" id="OleFileIO.open"><a class="viewcode-back" href="../../../../resources/dataexchange.xtomo.formats.xradia_xrm.html#dataexchange.xtomo.formats.xradia_xrm.OleFileIO.open">[docs]</a>    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Open an OLE2 file.</span>
<span class="sd">        Reads the header, FAT and directory.</span>

<span class="sd">        filename: string-like or file-like object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># check if filename is a string-like or file-like object:</span>
        <span class="c"># (it is better to check for a read() method)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;read&#39;</span><span class="p">):</span>
            <span class="c"># file-like object</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fp</span> <span class="o">=</span> <span class="n">filename</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># string-like object</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fp</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&quot;rb&quot;</span><span class="p">)</span>
        <span class="c"># old code fails if filename is not a plain string:   </span>
        <span class="c">#if type(filename) == type(&quot;&quot;):</span>
        <span class="c">#    self.fp = open(filename, &quot;rb&quot;)</span>
        <span class="c">#else:</span>
        <span class="c">#    self.fp = filename</span>

        <span class="c"># lists of streams in FAT and MiniFAT, to detect duplicate references</span>
        <span class="c"># (list of indexes of first sectors of each stream)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_used_streams_fat</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_used_streams_minifat</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">header</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fp</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">512</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">512</span> <span class="ow">or</span> <span class="n">header</span><span class="p">[:</span><span class="mi">8</span><span class="p">]</span> <span class="o">!=</span> <span class="n">MAGIC</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raise_defect</span><span class="p">(</span><span class="n">DEFECT_FATAL</span><span class="p">,</span> <span class="s">&quot;not an OLE2 structured storage file&quot;</span><span class="p">)</span>

        <span class="c"># [PL] header structure according to AAF specifications:</span>
        <span class="c">##Header</span>
        <span class="c">##struct StructuredStorageHeader { // [offset from start (bytes), length (bytes)]</span>
        <span class="c">##BYTE _abSig[8]; // [00H,08] {0xd0, 0xcf, 0x11, 0xe0, 0xa1, 0xb1,</span>
        <span class="c">##                // 0x1a, 0xe1} for current version</span>
        <span class="c">##CLSID _clsid;   // [08H,16] reserved must be zero (WriteClassStg/</span>
        <span class="c">##                // GetClassFile uses root directory class id)</span>
        <span class="c">##USHORT _uMinorVersion; // [18H,02] minor version of the format: 33 is</span>
        <span class="c">##                       // written by reference implementation</span>
        <span class="c">##USHORT _uDllVersion;   // [1AH,02] major version of the dll/format: 3 for</span>
        <span class="c">##                       // 512-byte sectors, 4 for 4 KB sectors</span>
        <span class="c">##USHORT _uByteOrder;    // [1CH,02] 0xFFFE: indicates Intel byte-ordering</span>
        <span class="c">##USHORT _uSectorShift;  // [1EH,02] size of sectors in power-of-two;</span>
        <span class="c">##                       // typically 9 indicating 512-byte sectors</span>
        <span class="c">##USHORT _uMiniSectorShift; // [20H,02] size of mini-sectors in power-of-two;</span>
        <span class="c">##                          // typically 6 indicating 64-byte mini-sectors</span>
        <span class="c">##USHORT _usReserved; // [22H,02] reserved, must be zero</span>
        <span class="c">##ULONG _ulReserved1; // [24H,04] reserved, must be zero</span>
        <span class="c">##FSINDEX _csectDir; // [28H,04] must be zero for 512-byte sectors,</span>
        <span class="c">##                   // number of SECTs in directory chain for 4 KB</span>
        <span class="c">##                   // sectors</span>
        <span class="c">##FSINDEX _csectFat; // [2CH,04] number of SECTs in the FAT chain</span>
        <span class="c">##SECT _sectDirStart; // [30H,04] first SECT in the directory chain</span>
        <span class="c">##DFSIGNATURE _signature; // [34H,04] signature used for transactions; must</span>
        <span class="c">##                        // be zero. The reference implementation</span>
        <span class="c">##                        // does not support transactions</span>
        <span class="c">##ULONG _ulMiniSectorCutoff; // [38H,04] maximum size for a mini stream;</span>
        <span class="c">##                           // typically 4096 bytes</span>
        <span class="c">##SECT _sectMiniFatStart; // [3CH,04] first SECT in the MiniFAT chain</span>
        <span class="c">##FSINDEX _csectMiniFat; // [40H,04] number of SECTs in the MiniFAT chain</span>
        <span class="c">##SECT _sectDifStart; // [44H,04] first SECT in the DIFAT chain</span>
        <span class="c">##FSINDEX _csectDif; // [48H,04] number of SECTs in the DIFAT chain</span>
        <span class="c">##SECT _sectFat[109]; // [4CH,436] the SECTs of first 109 FAT sectors</span>
        <span class="c">##};</span>

        <span class="c"># [PL] header decoding:</span>
        <span class="c"># &#39;&lt;&#39; indicates little-endian byte ordering for Intel (cf. struct module help)</span>
        <span class="n">fmt_header</span> <span class="o">=</span> <span class="s">&#39;&lt;8s16sHHHHHHLLLLLLLLLL&#39;</span>
        <span class="n">header_size</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">calcsize</span><span class="p">(</span><span class="n">fmt_header</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">DEBUG_MODE</span><span class="p">:</span> <span class="k">print</span>  <span class="s">&quot;fmt_header size = </span><span class="si">%d</span><span class="s">, +FAT = </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">header_size</span><span class="p">,</span> <span class="n">header_size</span> <span class="o">+</span> <span class="mi">109</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span> 
        <span class="n">header1</span> <span class="o">=</span> <span class="n">header</span><span class="p">[:</span><span class="n">header_size</span><span class="p">]</span>
        <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Sig</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clsid</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">MinorVersion</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">DllVersion</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ByteOrder</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SectorShift</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">MiniSectorShift</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Reserved</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Reserved1</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">csectDir</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">csectFat</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sectDirStart</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">signature</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">MiniSectorCutoff</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">MiniFatStart</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">csectMiniFat</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sectDifStart</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">csectDif</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">fmt_header</span><span class="p">,</span> <span class="n">header1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">DEBUG_MODE</span><span class="p">:</span> <span class="k">print</span>  <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">fmt_header</span><span class="p">,</span>    <span class="n">header1</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sig</span> <span class="o">!=</span> <span class="s">&#39;</span><span class="se">\xd0\xcf\x11\xe0\xa1\xb1\x1a\xe1</span><span class="s">&#39;</span><span class="p">:</span>
            <span class="c"># OLE signature should always be present</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raise_defect</span><span class="p">(</span><span class="n">DEFECT_FATAL</span><span class="p">,</span> <span class="s">&quot;incorrect OLE signature&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">clsid</span> <span class="o">!=</span> <span class="s">&#39;</span><span class="se">\x00</span><span class="s">&#39;</span><span class="o">*</span><span class="mi">16</span><span class="p">:</span>
            <span class="c"># according to AAF specs, CLSID should always be zero</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raise_defect</span><span class="p">(</span><span class="n">DEFECT_INCORRECT</span><span class="p">,</span> <span class="s">&quot;incorrect CLSID in OLE header&quot;</span><span class="p">)</span>
        <span class="c">#print  &quot;MinorVersion = %d&quot; , self.MinorVersion</span>
        <span class="c">#print  &quot;DllVersion   = %d&quot; , self.DllVersion </span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">DllVersion</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]:</span>
            <span class="c"># version 3: usual format, 512 bytes per sector</span>
            <span class="c"># version 4: large format, 4K per sector</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raise_defect</span><span class="p">(</span><span class="n">DEFECT_INCORRECT</span><span class="p">,</span> <span class="s">&quot;incorrect DllVersion in OLE header&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">DEBUG_MODE</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;ByteOrder    = </span><span class="si">%X</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">ByteOrder</span> 
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ByteOrder</span> <span class="o">!=</span> <span class="mh">0xFFFE</span><span class="p">:</span>
            <span class="c"># For now only common little-endian documents are handled correctly</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raise_defect</span><span class="p">(</span><span class="n">DEFECT_FATAL</span><span class="p">,</span> <span class="s">&quot;incorrect ByteOrder in OLE header&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">SectorSize</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">SectorShift</span>
        <span class="k">if</span> <span class="n">DEBUG_MODE</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;SectorSize   = </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">SectorSize</span> 
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SectorSize</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">512</span><span class="p">,</span> <span class="mi">4096</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raise_defect</span><span class="p">(</span><span class="n">DEFECT_INCORRECT</span><span class="p">,</span> <span class="s">&quot;incorrect SectorSize in OLE header&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DllVersion</span><span class="o">==</span><span class="mi">3</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">SectorSize</span><span class="o">!=</span><span class="mi">512</span><span class="p">)</span> \
        <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DllVersion</span><span class="o">==</span><span class="mi">4</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">SectorSize</span><span class="o">!=</span><span class="mi">4096</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raise_defect</span><span class="p">(</span><span class="n">DEFECT_INCORRECT</span><span class="p">,</span> <span class="s">&quot;SectorSize does not match DllVersion in OLE header&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">MiniSectorSize</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">MiniSectorShift</span>
        <span class="k">if</span> <span class="n">DEBUG_MODE</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;MiniSectorSize   = </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">MiniSectorSize</span> 
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">MiniSectorSize</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">64</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raise_defect</span><span class="p">(</span><span class="n">DEFECT_INCORRECT</span><span class="p">,</span> <span class="s">&quot;incorrect MiniSectorSize in OLE header&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Reserved</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">Reserved1</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raise_defect</span><span class="p">(</span><span class="n">DEFECT_INCORRECT</span><span class="p">,</span> <span class="s">&quot;incorrect OLE header (non-null reserved bytes)&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">DEBUG_MODE</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;number of directory sectors csectDir     = </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">csectDir</span> 
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SectorSize</span><span class="o">==</span><span class="mi">512</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">csectDir</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raise_defect</span><span class="p">(</span><span class="n">DEFECT_INCORRECT</span><span class="p">,</span> <span class="s">&quot;incorrect csectDir in OLE header&quot;</span><span class="p">)</span>
        <span class="c">#print  &quot;csectFat     = %d&quot; % self.csectFat </span>
        <span class="c">#print  &quot;sectDirStart = %X&quot; % self.sectDirStart </span>
        <span class="c">#print &quot;signature    = %d&quot; % self.signature </span>
        <span class="c"># Signature should be zero, BUT some implementations do not follow this</span>
        <span class="c"># rule =&gt; only a potential defect:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">signature</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raise_defect</span><span class="p">(</span><span class="n">DEFECT_POTENTIAL</span><span class="p">,</span> <span class="s">&quot;incorrect OLE header (signature&gt;0)&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">DEBUG_MODE</span><span class="p">:</span> 
            <span class="k">print</span> <span class="s">&quot;MiniSectorCutoff = </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">MiniSectorCutoff</span> 
            <span class="k">print</span> <span class="s">&quot;MiniFatStart     = </span><span class="si">%X</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">MiniFatStart</span> 
            <span class="k">print</span> <span class="s">&quot;csectMiniFat     = </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">csectMiniFat</span> 
            <span class="k">print</span> <span class="s">&quot;sectDifStart     = </span><span class="si">%X</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">sectDifStart</span> 
            <span class="k">print</span> <span class="s">&quot;csectDif         = </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">csectDif</span> 

        <span class="c"># calculate the number of sectors in the file</span>
        <span class="c"># (-1 because header doesn&#39;t count)</span>
        <span class="n">filesize</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getsize</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nb_sect</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="n">filesize</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">SectorSize</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">SectorSize</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c">#print &quot;Number of sectors in the file:&quot;,  self.nb_sect </span>

        <span class="c"># file clsid (probably never used, so we don&#39;t store it)</span>
        <span class="n">clsid</span> <span class="o">=</span> <span class="n">_clsid</span><span class="p">(</span><span class="n">header</span><span class="p">[</span><span class="mi">8</span><span class="p">:</span><span class="mi">24</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sectorsize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SectorSize</span> <span class="c">#1 &lt;&lt; i16(header, 30)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minisectorsize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MiniSectorSize</span>  <span class="c">#1 &lt;&lt; i16(header, 32)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minisectorcutoff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MiniSectorCutoff</span> <span class="c"># i32(header, 56)</span>

        <span class="c"># check known streams for duplicate references (these are always in FAT,</span>
        <span class="c"># never in MiniFAT):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_duplicate_stream</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sectDirStart</span><span class="p">)</span>
        <span class="c"># check MiniFAT only if it is not empty:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">csectMiniFat</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_duplicate_stream</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">MiniFatStart</span><span class="p">)</span>
        <span class="c"># check DIFAT only if it is not empty:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">csectDif</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_duplicate_stream</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sectDifStart</span><span class="p">)</span>

        <span class="c"># Load file allocation tables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loadfat</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>
        <span class="c"># Load direcory.  This sets both the direntries list (ordered by sid)</span>
        <span class="c"># and the root (ordered by hierarchy) members.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loaddirectory</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sectDirStart</span><span class="p">)</span><span class="c">#i32(header, 48))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ministream</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minifatsect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MiniFatStart</span> <span class="c">#i32(header, 60)</span>

</div>
    <span class="k">def</span> <span class="nf">_check_duplicate_stream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_sect</span><span class="p">,</span> <span class="n">minifat</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if a stream has not been already referenced elsewhere.</span>
<span class="sd">        This method should only be called once for each known stream, and only</span>
<span class="sd">        if stream size is not null.</span>
<span class="sd">        first_sect: index of first sector of the stream in FAT</span>
<span class="sd">        minifat: if True, stream is located in the MiniFAT, else in the FAT</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">minifat</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">DEBUG_MODE</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;_check_duplicate_stream: sect=</span><span class="si">%d</span><span class="s"> in MiniFAT&#39;</span> <span class="o">%</span> <span class="n">first_sect</span>
            <span class="n">used_streams</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_used_streams_minifat</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">DEBUG_MODE</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;_check_duplicate_stream: sect=</span><span class="si">%d</span><span class="s"> in FAT&#39;</span> <span class="o">%</span> <span class="n">first_sect</span>
            <span class="c"># some values can be safely ignored (not a real stream):</span>
            <span class="k">if</span> <span class="n">first_sect</span> <span class="ow">in</span> <span class="p">(</span><span class="n">DIFSECT</span><span class="p">,</span><span class="n">FATSECT</span><span class="p">,</span><span class="n">ENDOFCHAIN</span><span class="p">,</span><span class="n">FREESECT</span><span class="p">):</span>
                <span class="k">return</span>
            <span class="n">used_streams</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_used_streams_fat</span>
        
        <span class="k">if</span> <span class="n">first_sect</span> <span class="ow">in</span> <span class="n">used_streams</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raise_defect</span><span class="p">(</span><span class="n">DEFECT_INCORRECT</span><span class="p">,</span> <span class="s">&#39;Stream referenced twice&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">used_streams</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">first_sect</span><span class="p">)</span>


<div class="viewcode-block" id="OleFileIO.dumpfat"><a class="viewcode-back" href="../../../../resources/dataexchange.xtomo.formats.xradia_xrm.html#dataexchange.xtomo.formats.xradia_xrm.OleFileIO.dumpfat">[docs]</a>    <span class="k">def</span> <span class="nf">dumpfat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fat</span><span class="p">,</span> <span class="n">firstindex</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="s">&quot;Displays a part of FAT in human-readable form for debugging purpose&quot;</span>
        <span class="c"># [PL] added only for debug</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">DEBUG_MODE</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="c"># dictionary to convert special FAT values in human-readable strings</span>
        <span class="n">VPL</span><span class="o">=</span><span class="mi">8</span> <span class="c"># valeurs par ligne (8+1 * 8+1 = 81)</span>
        <span class="n">fatnames</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">FREESECT</span><span class="p">:</span>   <span class="s">&quot;..free..&quot;</span><span class="p">,</span>
            <span class="n">ENDOFCHAIN</span><span class="p">:</span> <span class="s">&quot;[ END. ]&quot;</span><span class="p">,</span>
            <span class="n">FATSECT</span><span class="p">:</span>    <span class="s">&quot;FATSECT &quot;</span><span class="p">,</span>
            <span class="n">DIFSECT</span><span class="p">:</span>    <span class="s">&quot;DIFSECT &quot;</span>
            <span class="p">}</span>
        <span class="n">nbsect</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fat</span><span class="p">)</span>
        <span class="n">nlines</span> <span class="o">=</span> <span class="p">(</span><span class="n">nbsect</span><span class="o">+</span><span class="n">VPL</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">VPL</span>
        <span class="k">print</span> <span class="s">&quot;index&quot;</span><span class="p">,</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">VPL</span><span class="p">):</span>
            <span class="k">print</span> <span class="p">(</span><span class="s">&quot;</span><span class="si">%8X</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">),</span>
        <span class="k">print</span> <span class="s">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nlines</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">l</span><span class="o">*</span><span class="n">VPL</span>
            <span class="k">print</span> <span class="p">(</span><span class="s">&quot;</span><span class="si">%8X</span><span class="s">:&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">firstindex</span><span class="o">+</span><span class="n">index</span><span class="p">)),</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">index</span><span class="o">+</span><span class="n">VPL</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span><span class="o">&gt;=</span><span class="n">nbsect</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">sect</span> <span class="o">=</span> <span class="n">fat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">sect</span> <span class="ow">in</span> <span class="n">fatnames</span><span class="p">:</span>
                    <span class="n">nom</span> <span class="o">=</span> <span class="n">fatnames</span><span class="p">[</span><span class="n">sect</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">sect</span> <span class="o">==</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">nom</span> <span class="o">=</span> <span class="s">&quot;    ---&gt;&quot;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">nom</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%8X</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">sect</span>
                <span class="k">print</span> <span class="n">nom</span><span class="p">,</span>
            <span class="k">print</span> <span class="s">&quot;&quot;</span>

</div>
<div class="viewcode-block" id="OleFileIO.dumpsect"><a class="viewcode-back" href="../../../../resources/dataexchange.xtomo.formats.xradia_xrm.html#dataexchange.xtomo.formats.xradia_xrm.OleFileIO.dumpsect">[docs]</a>    <span class="k">def</span> <span class="nf">dumpsect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sector</span><span class="p">,</span> <span class="n">firstindex</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="s">&quot;Displays a sector in a human-readable form, for debugging purpose.&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">DEBUG_MODE</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">VPL</span><span class="o">=</span><span class="mi">8</span> <span class="c"># number of values per line (8+1 * 8+1 = 81)</span>
        <span class="n">tab</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">UINT32</span><span class="p">,</span> <span class="n">sector</span><span class="p">)</span>
        <span class="n">nbsect</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tab</span><span class="p">)</span>
        <span class="n">nlines</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">nbsect</span><span class="o">+</span><span class="n">VPL</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">VPL</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">&quot;index&quot;</span><span class="p">,</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">VPL</span><span class="p">):</span>
            <span class="k">print</span> <span class="p">(</span><span class="s">&quot;</span><span class="si">%8X</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">),</span>
        <span class="k">print</span> <span class="s">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nlines</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">l</span><span class="o">*</span><span class="n">VPL</span>
            <span class="k">print</span> <span class="p">(</span><span class="s">&quot;</span><span class="si">%8X</span><span class="s">:&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">firstindex</span><span class="o">+</span><span class="n">index</span><span class="p">)),</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">index</span><span class="o">+</span><span class="n">VPL</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span><span class="o">&gt;=</span><span class="n">nbsect</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">sect</span> <span class="o">=</span> <span class="n">tab</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">nom</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%8X</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">sect</span>
                <span class="k">print</span> <span class="n">nom</span><span class="p">,</span>
            <span class="k">print</span> <span class="s">&quot;&quot;</span>
</div>
<div class="viewcode-block" id="OleFileIO.sect2array"><a class="viewcode-back" href="../../../../resources/dataexchange.xtomo.formats.xradia_xrm.html#dataexchange.xtomo.formats.xradia_xrm.OleFileIO.sect2array">[docs]</a>    <span class="k">def</span> <span class="nf">sect2array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sect</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        convert a sector to an array of 32 bits unsigned integers,</span>
<span class="sd">        swapping bytes on big endian CPUs such as PowerPC (old Macs)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">UINT32</span><span class="p">,</span> <span class="n">sect</span><span class="p">)</span>
        <span class="c"># if CPU is big endian, swap bytes:</span>
        <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">byteorder</span> <span class="o">==</span> <span class="s">&#39;big&#39;</span><span class="p">:</span>
            <span class="n">a</span><span class="o">.</span><span class="n">byteswap</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">a</span>        

</div>
<div class="viewcode-block" id="OleFileIO.loadfat_sect"><a class="viewcode-back" href="../../../../resources/dataexchange.xtomo.formats.xradia_xrm.html#dataexchange.xtomo.formats.xradia_xrm.OleFileIO.loadfat_sect">[docs]</a>    <span class="k">def</span> <span class="nf">loadfat_sect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sect</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds the indexes of the given sector to the FAT</span>
<span class="sd">        sect: string containing the first FAT sector, or array of long integers</span>
<span class="sd">        return: index of last FAT sector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># a FAT sector is an array of ulong integers.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sect</span><span class="p">,</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">):</span>
            <span class="c"># if sect is already an array it is directly used</span>
            <span class="n">fat1</span> <span class="o">=</span> <span class="n">sect</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># if it&#39;s a raw sector, it is parsed in an array</span>
            <span class="n">fat1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sect2array</span><span class="p">(</span><span class="n">sect</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dumpsect</span><span class="p">(</span><span class="n">sect</span><span class="p">)</span>
        <span class="c"># The FAT is a sector chain starting at the first index of itself.</span>
        <span class="k">for</span> <span class="n">isect</span> <span class="ow">in</span> <span class="n">fat1</span><span class="p">:</span>
            <span class="c">#print &quot;isect = %X&quot; % isect</span>
            <span class="k">if</span> <span class="n">isect</span> <span class="o">==</span> <span class="n">ENDOFCHAIN</span> <span class="ow">or</span> <span class="n">isect</span> <span class="o">==</span> <span class="n">FREESECT</span><span class="p">:</span>
                <span class="c"># the end of the sector chain has been reached</span>
                <span class="k">break</span>
            <span class="c"># read the FAT sector</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getsect</span><span class="p">(</span><span class="n">isect</span><span class="p">)</span>
            <span class="c"># parse it as an array of 32 bits integers, and add it to the</span>
            <span class="c"># global FAT array</span>
            <span class="n">nextfat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sect2array</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fat</span> <span class="o">+</span> <span class="n">nextfat</span>
        <span class="k">return</span> <span class="n">isect</span>

</div>
<div class="viewcode-block" id="OleFileIO.loadfat"><a class="viewcode-back" href="../../../../resources/dataexchange.xtomo.formats.xradia_xrm.html#dataexchange.xtomo.formats.xradia_xrm.OleFileIO.loadfat">[docs]</a>    <span class="k">def</span> <span class="nf">loadfat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">header</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load the FAT table.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># The header contains a sector  numbers</span>
        <span class="c"># for the first 109 FAT sectors.  Additional sectors are</span>
        <span class="c"># described by DIF blocks</span>

        <span class="n">sect</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="mi">76</span><span class="p">:</span><span class="mi">512</span><span class="p">]</span>

        <span class="c"># [PL] FAT is an array of 32 bits unsigned ints, it&#39;s more effective</span>
        <span class="c"># to use an array than a list in Python.</span>
        <span class="c"># It&#39;s initialized as empty first:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fat</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">UINT32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loadfat_sect</span><span class="p">(</span><span class="n">sect</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">csectDif</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># [PL] There&#39;s a DIFAT because file is larger than 6.8MB</span>
            <span class="c"># some checks just in case:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">csectFat</span> <span class="o">&lt;=</span> <span class="mi">109</span><span class="p">:</span>
                <span class="c"># there must be at least 109 blocks in header and the rest in</span>
                <span class="c"># DIFAT, so number of sectors must be &gt;109.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_raise_defect</span><span class="p">(</span><span class="n">DEFECT_INCORRECT</span><span class="p">,</span> <span class="s">&#39;incorrect DIFAT, not enough sectors&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sectDifStart</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_sect</span><span class="p">:</span>
                <span class="c"># initial DIFAT block index must be valid</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_raise_defect</span><span class="p">(</span><span class="n">DEFECT_FATAL</span><span class="p">,</span> <span class="s">&#39;incorrect DIFAT, first index out of range&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">DEBUG_MODE</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;DIFAT analysis...&quot;</span> 
            <span class="c"># We compute the necessary number of DIFAT sectors :</span>
            <span class="c"># (each DIFAT sector = 127 pointers + 1 towards next DIFAT sector)</span>
            <span class="n">nb_difat</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">csectFat</span><span class="o">-</span><span class="mi">109</span> <span class="o">+</span> <span class="mi">126</span><span class="p">)</span><span class="o">/</span><span class="mi">127</span>
            <span class="k">if</span> <span class="n">DEBUG_MODE</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;nb_difat = </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">nb_difat</span> 
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">csectDif</span> <span class="o">!=</span> <span class="n">nb_difat</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">,</span> <span class="s">&#39;incorrect DIFAT&#39;</span>
            <span class="n">isect_difat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sectDifStart</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nb_difat</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">DEBUG_MODE</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;DIFAT block </span><span class="si">%d</span><span class="s">, sector </span><span class="si">%X</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">isect_difat</span><span class="p">)</span> 

                <span class="n">sector_difat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getsect</span><span class="p">(</span><span class="n">isect_difat</span><span class="p">)</span>
                <span class="n">difat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sect2array</span><span class="p">(</span><span class="n">sector_difat</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dumpsect</span><span class="p">(</span><span class="n">sector_difat</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">loadfat_sect</span><span class="p">(</span><span class="n">difat</span><span class="p">[:</span><span class="mi">127</span><span class="p">])</span>
                <span class="c"># last DIFAT pointer is next DIFAT sector:</span>
                <span class="n">isect_difat</span> <span class="o">=</span> <span class="n">difat</span><span class="p">[</span><span class="mi">127</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">DEBUG_MODE</span><span class="p">:</span> <span class="k">print</span> <span class="s">&quot;next DIFAT sector: </span><span class="si">%X</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">isect_difat</span> 
            <span class="c"># checks:</span>
            <span class="k">if</span> <span class="n">isect_difat</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ENDOFCHAIN</span><span class="p">,</span> <span class="n">FREESECT</span><span class="p">]:</span>
                <span class="c"># last DIFAT pointer value must be ENDOFCHAIN or FREESECT</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">,</span> <span class="s">&#39;incorrect end of DIFAT&#39;</span>

        <span class="c"># since FAT is read from fixed-size sectors, it may contain more values</span>
        <span class="c"># than the actual number of sectors in the file.</span>
        

        <span class="c"># Keep only the relevant sector indexes:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fat</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_sect</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">DEBUG_MODE</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;len(fat)=</span><span class="si">%d</span><span class="s">, shrunk to nb_sect=</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fat</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_sect</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fat</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_sect</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">DEBUG_MODE</span><span class="p">:</span> <span class="k">print</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">FAT:&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dumpfat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fat</span><span class="p">)</span>
        

</div>
<div class="viewcode-block" id="OleFileIO.loadminifat"><a class="viewcode-back" href="../../../../resources/dataexchange.xtomo.formats.xradia_xrm.html#dataexchange.xtomo.formats.xradia_xrm.OleFileIO.loadminifat">[docs]</a>    <span class="k">def</span> <span class="nf">loadminifat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load the MiniFAT table.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># MiniFAT is stored in a standard  sub-stream, pointed to by a header</span>
        <span class="c"># field.</span>
        <span class="c"># NOTE: there are two sizes to take into account for this stream:</span>
        <span class="c"># 1) Stream size is calculated according to the number of sectors</span>
        <span class="c">#    declared in the OLE header. This allocated stream may be more than</span>
        <span class="c">#    needed to store the actual sector indexes.</span>
        <span class="c"># (self.csectMiniFat is the number of sectors of size self.SectorSize)</span>
        <span class="n">stream_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">csectMiniFat</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">SectorSize</span>
        <span class="c"># 2) Actually used size is calculated by dividing the MiniStream size</span>
        <span class="c">#    (given by root entry size) by the size of mini sectors, *4 for</span>
        <span class="c">#    32 bits indexes:</span>
        <span class="n">nb_minisectors</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">MiniSectorSize</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">MiniSectorSize</span>
        <span class="n">used_size</span> <span class="o">=</span> <span class="n">nb_minisectors</span> <span class="o">*</span> <span class="mi">4</span>
        <span class="k">if</span> <span class="n">DEBUG_MODE</span><span class="p">:</span> <span class="k">print</span> <span class="p">(</span><span class="s">&#39;loadminifat(): minifatsect=</span><span class="si">%d</span><span class="s">, nb FAT sectors=</span><span class="si">%d</span><span class="s">, used_size=</span><span class="si">%d</span><span class="s">, stream_size=</span><span class="si">%d</span><span class="s">, nb MiniSectors=</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minifatsect</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">csectMiniFat</span><span class="p">,</span> <span class="n">used_size</span><span class="p">,</span> <span class="n">stream_size</span><span class="p">,</span> <span class="n">nb_minisectors</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">used_size</span> <span class="o">&gt;</span> <span class="n">stream_size</span><span class="p">:</span>
            <span class="c"># This is not really a problem, but may indicate a wrong implementation:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raise_defect</span><span class="p">(</span><span class="n">DEFECT_INCORRECT</span><span class="p">,</span> <span class="s">&#39;OLE MiniStream is larger than MiniFAT&#39;</span><span class="p">)</span>
        <span class="c"># In any case, first read stream_size:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minifatsect</span><span class="p">,</span> <span class="n">stream_size</span><span class="p">,</span> <span class="n">force_FAT</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="c">#[PL] Old code replaced by an array:</span>
        <span class="c">#self.minifat = map(lambda i, s=s: i32(s, i), range(0, len(s), 4))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minifat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sect2array</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="c"># Then shrink the array to used size, to avoid indexes out of MiniStream:</span>
        <span class="k">if</span> <span class="n">DEBUG_MODE</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;MiniFAT shrunk from </span><span class="si">%d</span><span class="s"> to </span><span class="si">%d</span><span class="s"> sectors&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minifat</span><span class="p">),</span> <span class="n">nb_minisectors</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minifat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minifat</span><span class="p">[:</span><span class="n">nb_minisectors</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">DEBUG_MODE</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;loadminifat(): len=</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minifat</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">DEBUG_MODE</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">MiniFAT:&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dumpfat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minifat</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="OleFileIO.getsect"><a class="viewcode-back" href="../../../../resources/dataexchange.xtomo.formats.xradia_xrm.html#dataexchange.xtomo.formats.xradia_xrm.OleFileIO.getsect">[docs]</a>    <span class="k">def</span> <span class="nf">getsect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sect</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read given sector from file on disk.</span>
<span class="sd">        sect: sector index</span>
<span class="sd">        returns a string containing the sector data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># [PL] this original code was wrong when sectors are 4KB instead of</span>
        <span class="c"># 512 bytes:</span>
        <span class="c">#self.fp.seek(512 + self.sectorsize * sect)</span>
        <span class="c">#[PL]: added safety checks:</span>
        <span class="c">#print &quot;getsect(%X)&quot; % sect</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fp</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sectorsize</span> <span class="o">*</span> <span class="p">(</span><span class="n">sect</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">DEBUG_MODE</span><span class="p">:</span> <span class="k">print</span> <span class="p">(</span><span class="s">&#39;getsect(): sect=</span><span class="si">%X</span><span class="s">, seek=</span><span class="si">%d</span><span class="s">, filesize=</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span>
                <span class="p">(</span><span class="n">sect</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sectorsize</span><span class="o">*</span><span class="p">(</span><span class="n">sect</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getsize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fp</span><span class="o">.</span><span class="n">name</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raise_defect</span><span class="p">(</span><span class="n">DEFECT_FATAL</span><span class="p">,</span> <span class="s">&#39;OLE sector index out of range&#39;</span><span class="p">)</span>
        <span class="n">sector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fp</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sectorsize</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sector</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sectorsize</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">DEBUG_MODE</span><span class="p">:</span> <span class="k">print</span> <span class="p">(</span><span class="s">&#39;getsect(): sect=</span><span class="si">%X</span><span class="s">, read=</span><span class="si">%d</span><span class="s">, sectorsize=</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span>
                <span class="p">(</span><span class="n">sect</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sector</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">sectorsize</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raise_defect</span><span class="p">(</span><span class="n">DEFECT_FATAL</span><span class="p">,</span> <span class="s">&#39;incomplete OLE sector&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sector</span>

</div>
<div class="viewcode-block" id="OleFileIO.loaddirectory"><a class="viewcode-back" href="../../../../resources/dataexchange.xtomo.formats.xradia_xrm.html#dataexchange.xtomo.formats.xradia_xrm.OleFileIO.loaddirectory">[docs]</a>    <span class="k">def</span> <span class="nf">loaddirectory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sect</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load the directory.</span>
<span class="sd">        sect: sector index of directory stream.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># The directory is  stored in a standard</span>
        <span class="c"># substream, independent of its size.</span>

        <span class="c"># open directory stream as a read-only file:</span>
        <span class="c"># (stream size is not known in advance)</span>
        
        <span class="c">#ML: size is equal to the number of directory sectors times sector size</span>
        <span class="c"># self.csectDir * self.sectorsize</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">directory_fp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_open</span><span class="p">(</span><span class="n">sect</span><span class="p">)</span>
        
        

        <span class="c">#[PL] to detect malformed documents and avoid DoS attacks, the maximum</span>
        <span class="c"># number of directory entries can be calculated:</span>
        <span class="n">max_entries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">directory_fp</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="mi">128</span>
        <span class="k">if</span> <span class="n">DEBUG_MODE</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;loaddirectory: size=</span><span class="si">%d</span><span class="s">, max_entries=</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory_fp</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">max_entries</span><span class="p">)</span>

        <span class="c"># Create list of directory entries</span>
        <span class="c"># We start with a list of &quot;None&quot; object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">direntries</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">max_entries</span>

        <span class="c"># load root entry:</span>
        <span class="n">root_entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_direntry</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c"># Root entry is the first entry:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">direntries</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c"># read and build all storage trees, starting from the root:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">build_storage_tree</span><span class="p">()</span>

</div>
    <span class="k">def</span> <span class="nf">_load_direntry</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load a directory entry from the directory.</span>
<span class="sd">        This method should only be called once for each storage/stream when</span>
<span class="sd">        loading the directory.</span>
<span class="sd">        sid: index of storage/stream in the directory.</span>
<span class="sd">        return: a _OleDirectoryEntry object</span>
<span class="sd">        raise: IOError if the entry has always been referenced.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># check if SID is OK:</span>
        <span class="k">if</span> <span class="n">sid</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">sid</span><span class="o">&gt;=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">direntries</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raise_defect</span><span class="p">(</span><span class="n">DEFECT_FATAL</span><span class="p">,</span> <span class="s">&quot;OLE directory index out of range&quot;</span><span class="p">)</span>
        <span class="c"># check if entry was already referenced:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">direntries</span><span class="p">[</span><span class="n">sid</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raise_defect</span><span class="p">(</span><span class="n">DEFECT_INCORRECT</span><span class="p">,</span>
                <span class="s">&quot;double reference for OLE stream/storage&quot;</span><span class="p">)</span>
            <span class="c"># if exception not raised, return the object</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">direntries</span><span class="p">[</span><span class="n">sid</span><span class="p">]</span>
        <span class="c">#print &quot;dir enntry sid = &quot;, sid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">directory_fp</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">sid</span> <span class="o">*</span> <span class="mi">128</span><span class="p">)</span>
        <span class="n">entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">directory_fp</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">direntries</span><span class="p">[</span><span class="n">sid</span><span class="p">]</span> <span class="o">=</span> <span class="n">_OleDirectoryEntry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">sid</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">direntries</span><span class="p">[</span><span class="n">sid</span><span class="p">]</span>


<div class="viewcode-block" id="OleFileIO.dumpdirectory"><a class="viewcode-back" href="../../../../resources/dataexchange.xtomo.formats.xradia_xrm.html#dataexchange.xtomo.formats.xradia_xrm.OleFileIO.dumpdirectory">[docs]</a>    <span class="k">def</span> <span class="nf">dumpdirectory</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dump directory (for debugging only)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">dump</span><span class="p">()</span>

</div>
    <span class="k">def</span> <span class="nf">_open</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="mh">0x7FFFFFFF</span><span class="p">,</span> <span class="n">force_FAT</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Open a stream, either in FAT or MiniFAT according to its size.</span>
<span class="sd">        (openstream helper)</span>

<span class="sd">        start: index of first sector</span>
<span class="sd">        size: size of stream (or nothing if size is unknown)</span>
<span class="sd">        force_FAT: if False (default), stream will be opened in FAT or MiniFAT</span>
<span class="sd">                   according to size. If True, it will always be opened in FAT.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#print &#39;OleFileIO.open(): sect=%d, size=%d, force_FAT=%s&#39; % (start, size, str(force_FAT))</span>
        <span class="c"># stream size is compared to the MiniSectorCutoff threshold:</span>
        <span class="k">if</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minisectorcutoff</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">force_FAT</span><span class="p">:</span>
            <span class="c"># ministream object</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ministream</span><span class="p">:</span>
                <span class="c"># load MiniFAT if it wasn&#39;t already done:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">loadminifat</span><span class="p">()</span>
                <span class="c"># The first sector index of the miniFAT stream is stored in the</span>
                <span class="c"># root directory entry:</span>
                <span class="n">size_ministream</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">size</span>
                <span class="k">if</span> <span class="n">DEBUG_MODE</span><span class="p">:</span> <span class="k">print</span> <span class="p">(</span><span class="s">&#39;Opening MiniStream: sect=</span><span class="si">%d</span><span class="s">, size=</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">isectStart</span><span class="p">,</span> <span class="n">size_ministream</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ministream</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">isectStart</span><span class="p">,</span>
                    <span class="n">size_ministream</span><span class="p">,</span> <span class="n">force_FAT</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">_OleStream</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ministream</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">minisectorsize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">minifat</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># standard stream</span>
<span class="c">#            return _OleStream(self.fp, start, size, 512,</span>
<span class="c">#                              self.sectorsize, self.fat)</span>
            <span class="k">return</span> <span class="n">_OleStream</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fp</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sectorsize</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">sectorsize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fat</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">files</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (listdir helper)</span>
<span class="sd">        files: list of files to fill in</span>
<span class="sd">        prefix: current location in storage tree (list of names)</span>
<span class="sd">        node: current node (_OleDirectoryEntry object)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">kids</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">entry</span><span class="o">.</span><span class="n">kids</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_list</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prefix</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="p">[</span><span class="n">entry</span><span class="o">.</span><span class="n">name</span><span class="p">])</span>


<div class="viewcode-block" id="OleFileIO.listdir"><a class="viewcode-back" href="../../../../resources/dataexchange.xtomo.formats.xradia_xrm.html#dataexchange.xtomo.formats.xradia_xrm.OleFileIO.listdir">[docs]</a>    <span class="k">def</span> <span class="nf">listdir</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of streams stored in this file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">files</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_list</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="p">[],</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">files</span>

</div>
    <span class="k">def</span> <span class="nf">_find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns directory entry of given filename. (openstream helper)</span>
<span class="sd">        Note: this method is case-insensitive.</span>

<span class="sd">        filename: path of stream in storage tree (except root entry), either:</span>
<span class="sd">            - a string using Unix path syntax, for example:</span>
<span class="sd">              &#39;storage_1/storage_1.2/stream&#39;</span>
<span class="sd">            - a list of storage filenames, path to the desired stream/storage.</span>
<span class="sd">              Example: [&#39;storage_1&#39;, &#39;storage_1.2&#39;, &#39;stream&#39;]</span>
<span class="sd">        return: sid of requested filename</span>
<span class="sd">        raise IOError if file not found</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># if filename is a string instead of a list, split it on slashes to</span>
        <span class="c"># convert to a list:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
        <span class="c"># walk across storage tree, following given path:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">filename</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">kid</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">kids</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">kid</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">,</span> <span class="s">&quot;file not found&quot;</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">kid</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">sid</span>


<div class="viewcode-block" id="OleFileIO.openstream"><a class="viewcode-back" href="../../../../resources/dataexchange.xtomo.formats.xradia_xrm.html#dataexchange.xtomo.formats.xradia_xrm.OleFileIO.openstream">[docs]</a>    <span class="k">def</span> <span class="nf">openstream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Open a stream as a read-only file object (StringIO).</span>

<span class="sd">        filename: path of stream in storage tree (except root entry), either:</span>
<span class="sd">            - a string using Unix path syntax, for example:</span>
<span class="sd">              &#39;storage_1/storage_1.2/stream&#39;</span>
<span class="sd">            - a list of storage filenames, path to the desired stream/storage.</span>
<span class="sd">              Example: [&#39;storage_1&#39;, &#39;storage_1.2&#39;, &#39;stream&#39;]</span>
<span class="sd">        return: file object (read-only)</span>
<span class="sd">        raise IOError if filename not found, or if this is not a stream.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">direntries</span><span class="p">[</span><span class="n">sid</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">entry</span><span class="o">.</span><span class="n">entry_type</span> <span class="o">!=</span> <span class="n">STGTY_STREAM</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">,</span> <span class="s">&quot;this file is not a stream&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_open</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">isectStart</span><span class="p">,</span> <span class="n">entry</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="OleFileIO.get_type"><a class="viewcode-back" href="../../../../resources/dataexchange.xtomo.formats.xradia_xrm.html#dataexchange.xtomo.formats.xradia_xrm.OleFileIO.get_type">[docs]</a>    <span class="k">def</span> <span class="nf">get_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if given filename exists as a stream or a storage in the OLE</span>
<span class="sd">        container, and return its type.</span>

<span class="sd">        filename: path of stream in storage tree. (see openstream for syntax)</span>
<span class="sd">        return: False if object does not exist, its entry type (&gt;0) otherwise:</span>
<span class="sd">            - STGTY_STREAM: a stream</span>
<span class="sd">            - STGTY_STORAGE: a storage</span>
<span class="sd">            - STGTY_ROOT: the root entry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
            <span class="n">entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">direntries</span><span class="p">[</span><span class="n">sid</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">entry</span><span class="o">.</span><span class="n">entry_type</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

</div>
<div class="viewcode-block" id="OleFileIO.exists"><a class="viewcode-back" href="../../../../resources/dataexchange.xtomo.formats.xradia_xrm.html#dataexchange.xtomo.formats.xradia_xrm.OleFileIO.exists">[docs]</a>    <span class="k">def</span> <span class="nf">exists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if given filename exists as a stream or a storage in the OLE</span>
<span class="sd">        container.</span>

<span class="sd">        filename: path of stream in storage tree. (see openstream for syntax)</span>
<span class="sd">        return: True if object exist, else False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

</div>
<div class="viewcode-block" id="OleFileIO.get_size"><a class="viewcode-back" href="../../../../resources/dataexchange.xtomo.formats.xradia_xrm.html#dataexchange.xtomo.formats.xradia_xrm.OleFileIO.get_size">[docs]</a>    <span class="k">def</span> <span class="nf">get_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return size of a stream in the OLE container, in bytes.</span>

<span class="sd">        filename: path of stream in storage tree (see openstream for syntax)</span>
<span class="sd">        return: size in bytes (long integer)</span>
<span class="sd">        raise: IOError if file not found, TypeError if this is not a stream.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">direntries</span><span class="p">[</span><span class="n">sid</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">entry</span><span class="o">.</span><span class="n">entry_type</span> <span class="o">!=</span> <span class="n">STGTY_STREAM</span><span class="p">:</span>

            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">,</span> <span class="s">&#39;object is not an OLE stream&#39;</span>
        <span class="k">return</span> <span class="n">entry</span><span class="o">.</span><span class="n">size</span>

</div>
<div class="viewcode-block" id="OleFileIO.get_rootentry_name"><a class="viewcode-back" href="../../../../resources/dataexchange.xtomo.formats.xradia_xrm.html#dataexchange.xtomo.formats.xradia_xrm.OleFileIO.get_rootentry_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_rootentry_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return root entry name. Should usually be &#39;Root Entry&#39; or &#39;R&#39; in most</span>
<span class="sd">        implementations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">name</span>

</div>
<div class="viewcode-block" id="OleFileIO.getproperties"><a class="viewcode-back" href="../../../../resources/dataexchange.xtomo.formats.xradia_xrm.html#dataexchange.xtomo.formats.xradia_xrm.OleFileIO.getproperties">[docs]</a>    <span class="k">def</span> <span class="nf">getproperties</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return properties described in substream.</span>

<span class="sd">        filename: path of stream in storage tree (see openstream for syntax)</span>
<span class="sd">        return: a dictionary of values indexed by id (integer)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">openstream</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c"># header</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">28</span><span class="p">)</span>
        <span class="n">clsid</span> <span class="o">=</span> <span class="n">_clsid</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">8</span><span class="p">:</span><span class="mi">24</span><span class="p">])</span>

        <span class="c"># format id</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
        <span class="n">fmtid</span> <span class="o">=</span> <span class="n">_clsid</span><span class="p">(</span><span class="n">s</span><span class="p">[:</span><span class="mi">16</span><span class="p">])</span>
        <span class="n">fp</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">i32</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">16</span><span class="p">))</span>

        <span class="c"># get section</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;****&quot;</span> <span class="o">+</span> <span class="n">fp</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">i32</span><span class="p">(</span><span class="n">fp</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span><span class="o">-</span><span class="mi">4</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i32</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">4</span><span class="p">)):</span>

            <span class="nb">id</span> <span class="o">=</span> <span class="n">i32</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">8</span><span class="o">+</span><span class="n">i</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">i32</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">12</span><span class="o">+</span><span class="n">i</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span>
            <span class="nb">type</span> <span class="o">=</span> <span class="n">i32</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">DEBUG_MODE</span><span class="p">:</span> <span class="k">print</span> <span class="s">&#39;property id=</span><span class="si">%d</span><span class="s">: type=</span><span class="si">%d</span><span class="s"> offset=</span><span class="si">%X</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>

            <span class="c"># test for common types first (should perhaps use</span>
            <span class="c"># a dictionary instead?)</span>

            <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="n">VT_I2</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">i16</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">offset</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;=</span> <span class="mi">32768</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">value</span> <span class="o">-</span> <span class="mi">65536</span>
            <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="n">VT_UI2</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">i16</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">offset</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">type</span> <span class="ow">in</span> <span class="p">(</span><span class="n">VT_I4</span><span class="p">,</span> <span class="n">VT_ERROR</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">i32</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">offset</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="n">VT_UI4</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">i32</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">offset</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span> <span class="c"># FIXME</span>
            <span class="k">elif</span> <span class="nb">type</span> <span class="ow">in</span> <span class="p">(</span><span class="n">VT_BSTR</span><span class="p">,</span> <span class="n">VT_LPSTR</span><span class="p">):</span>
                <span class="n">count</span> <span class="o">=</span> <span class="n">i32</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">offset</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="mi">8</span><span class="p">:</span><span class="n">offset</span><span class="o">+</span><span class="mi">8</span><span class="o">+</span><span class="n">count</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="n">VT_BLOB</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">=</span> <span class="n">i32</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">offset</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="mi">8</span><span class="p">:</span><span class="n">offset</span><span class="o">+</span><span class="mi">8</span><span class="o">+</span><span class="n">count</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="n">VT_LPWSTR</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">=</span> <span class="n">i32</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">offset</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unicode</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="mi">8</span><span class="p">:</span><span class="n">offset</span><span class="o">+</span><span class="mi">8</span><span class="o">+</span><span class="n">count</span><span class="o">*</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="n">VT_FILETIME</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">long</span><span class="p">(</span><span class="n">i32</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">offset</span><span class="o">+</span><span class="mi">4</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="nb">long</span><span class="p">(</span><span class="n">i32</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">offset</span><span class="o">+</span><span class="mi">8</span><span class="p">))</span><span class="o">&lt;&lt;</span><span class="mi">32</span><span class="p">)</span>
                <span class="c"># This is a 64-bit int: &quot;number of 100ns periods</span>
                <span class="c"># since Jan 1,1601&quot;.  Should map this to Python time</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span> <span class="o">/</span> <span class="il">10000000L</span> <span class="c"># seconds</span>
            <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="n">VT_UI1</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="mi">4</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="n">VT_CLSID</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">_clsid</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="mi">4</span><span class="p">:</span><span class="n">offset</span><span class="o">+</span><span class="mi">20</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="n">VT_CF</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">=</span> <span class="n">i32</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">offset</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="mi">8</span><span class="p">:</span><span class="n">offset</span><span class="o">+</span><span class="mi">8</span><span class="o">+</span><span class="n">count</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">None</span> <span class="c"># everything else yields &quot;None&quot;</span>


            <span class="k">if</span> <span class="n">DEBUG_MODE</span><span class="p">:</span> 
                <span class="k">print</span> <span class="s">&quot;</span><span class="si">%08x</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">id</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">value</span><span class="p">),</span>
                <span class="k">print</span> <span class="s">&quot;(</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="n">VT</span><span class="p">[</span><span class="n">i32</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFF</span><span class="p">]</span>

            <span class="n">data</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">return</span> <span class="n">data</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../../index.html">Data Exchange 0.2 documentation</a> &raquo;</li>
          <li><a href="../../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Argonne National Laboratory.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>